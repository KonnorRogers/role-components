{
  "schemaVersion": "1.0.0",
  "readme": "",
  "modules": [
    {
      "kind": "javascript-module",
      "path": "exports/base-element.js",
      "declarations": [
        {
          "kind": "class",
          "description": "",
          "name": "BaseElement",
          "members": [
            {
              "kind": "field",
              "name": "dependencies",
              "static": true,
              "type": {
                "text": "Record<string, typeof HTMLElement>"
              },
              "readonly": true
            },
            {
              "kind": "method",
              "name": "debounce",
              "parameters": [
                {
                  "name": "callback",
                  "type": {
                    "text": "(...args: any[]) => any"
                  }
                },
                {
                  "name": "options",
                  "type": {
                    "text": "{ key: any, wait: number }"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "ReturnType<typeof setTimeout>"
                }
              }
            },
            {
              "kind": "field",
              "name": "eventHandler",
              "type": {
                "text": "EventHandler<this>"
              },
              "default": "new EventHandler(this)"
            },
            {
              "kind": "field",
              "name": "__debounceMap__",
              "type": {
                "text": "null | Map<any, ReturnType<typeof setTimeout>>"
              },
              "default": "null"
            }
          ],
          "mixins": [
            {
              "name": "DefineableMixin",
              "package": "web-component-define"
            }
          ],
          "superclass": {
            "name": "LitElement",
            "package": "lit"
          },
          "customElement": true
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "BaseElement",
          "declaration": {
            "name": "BaseElement",
            "module": "exports/base-element.js"
          }
        },
        {
          "kind": "custom-element-definition",
          "name": "key",
          "declaration": {
            "name": "ctor",
            "module": "exports/base-element.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/index.js",
      "declarations": [],
      "exports": [
        {
          "kind": "js",
          "name": "RoleCombobox",
          "declaration": {
            "name": "default",
            "module": "\"./combobox/combobox-register.js\""
          }
        },
        {
          "kind": "js",
          "name": "RoleListbox",
          "declaration": {
            "name": "default",
            "module": "\"./listbox/listbox-register.js\""
          }
        },
        {
          "kind": "js",
          "name": "RoleOptionGroup",
          "declaration": {
            "name": "default",
            "module": "\"./option-group/option-group-register.js\""
          }
        },
        {
          "kind": "js",
          "name": "RoleOption",
          "declaration": {
            "name": "default",
            "module": "\"./option/option-register.js\""
          }
        },
        {
          "kind": "js",
          "name": "RoleToolbar",
          "declaration": {
            "name": "default",
            "module": "\"./toolbar/toolbar-register.js\""
          }
        },
        {
          "kind": "js",
          "name": "RoleTooltip",
          "declaration": {
            "name": "default",
            "module": "\"./tooltip/tooltip-register.js\""
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/anchored-region/anchored-region-register.js",
      "declarations": [],
      "exports": [
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "RoleAnchoredRegion",
            "module": "exports/anchored-region/anchored-region-register.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/anchored-region/anchored-region.js",
      "declarations": [
        {
          "kind": "mixin",
          "description": "",
          "name": "AnchoredRegionMixin",
          "members": [
            {
              "kind": "field",
              "name": "placement",
              "description": "The preferred placement of the popover. Note that the actual placement will vary as configured to keep the\npanel inside of the viewport.",
              "type": {
                "text": "'top'\n          | 'top-start'\n          | 'top-end'\n          | 'bottom'\n          | 'bottom-start'\n          | 'bottom-end'\n          | 'right'\n          | 'right-start'\n          | 'right-end'\n          | 'left'\n          | 'left-start'\n          | 'left-end'"
              },
              "attribute": "placement"
            },
            {
              "kind": "field",
              "name": "currentPlacement",
              "description": "The `currentPlacement` property / `current-placement` attribute are where Floating UI actually positions the popup.",
              "reflects": true,
              "type": {
                "text": "this[\"placement\"] | null"
              },
              "attribute": "current-placement"
            },
            {
              "kind": "field",
              "name": "strategy",
              "description": "Determines how the popover is positioned. Because you native \"popover\" API uses a fixed strategy, we use it as the default.",
              "type": {
                "text": "Strategy"
              },
              "attribute": "strategy"
            },
            {
              "kind": "field",
              "name": "distance",
              "description": "The distance in pixels from which to offset along the \"main axis\". Usually its equivalent to offsetY",
              "type": {
                "text": "number"
              },
              "attribute": "distance"
            },
            {
              "kind": "field",
              "name": "skidding",
              "description": "The distance in pixels from which to offset along the \"cross axis\". Usually its equivalent to offsetX.",
              "type": {
                "text": "number"
              },
              "attribute": "skidding"
            },
            {
              "kind": "field",
              "name": "arrow",
              "description": "Attaches an arrow to the popover. The arrow's size and color can be customized using the `--arrow-size` and\n`--background-color` custom properties. For additional customizations, you can also target the arrow using\n`::part(arrow)` in your stylesheet.",
              "type": {
                "text": "boolean"
              },
              "attribute": "arrow"
            },
            {
              "kind": "field",
              "name": "arrowPlacement",
              "description": "The placement of the arrow. The default is `anchor`, which will align the arrow as close to the center of the\nanchor as possible, considering available space and `arrow-padding`. A value of `start`, `end`, or `center` will\nalign the arrow to the start, end, or center of the popover instead.",
              "type": {
                "text": "'start' | 'end' | 'center' | 'anchor'"
              },
              "attribute": "arrow-placement"
            },
            {
              "kind": "field",
              "name": "arrowPadding",
              "description": "The amount of padding between the arrow and the edges of the popover. If the popover has a border-radius, for example,\nthis will prevent it from overflowing the corners.",
              "type": {
                "text": "number"
              },
              "attribute": "arrow-padding"
            },
            {
              "kind": "field",
              "name": "flip",
              "description": "When set, placement of the popover will flip to the opposite site to keep it in view. You can use\n`flipFallbackPlacements` to further configure how the fallback placement is determined.",
              "type": {
                "text": "boolean"
              },
              "attribute": "flip"
            },
            {
              "kind": "field",
              "name": "flipFallbackPlacements",
              "description": "If the preferred placement doesn't fit, popover will be tested in these fallback placements until one fits. Must be a\nstring of any number of placements separated by a space, e.g. \"top bottom left\". If no placement fits, the flip\nfallback strategy will be used instead.",
              "type": {
                "text": "string"
              },
              "attribute": "flip-fallback-placements"
            },
            {
              "kind": "field",
              "name": "flipFallbackStrategy",
              "description": "When neither the preferred placement nor the fallback placements fit, this value will be used to determine whether\nthe popover should be positioned using the best available fit based on available space or as it was initially\npreferred.",
              "type": {
                "text": "'best-fit' | 'initial'"
              },
              "attribute": "flip-fallback-strategy"
            },
            {
              "kind": "field",
              "name": "flipBoundary",
              "description": "The flip boundary describes clipping element(s) that overflow will be checked relative to when flipping. By\ndefault, the boundary includes overflow ancestors that will cause the element to be clipped. If needed, you can\nchange the boundary by passing a reference to one or more elements to this property.",
              "type": {
                "text": "undefined | Element | Element[]"
              }
            },
            {
              "kind": "field",
              "name": "flipPadding",
              "description": "The amount of padding, in pixels, to exceed before the flip behavior will occur.",
              "type": {
                "text": "number"
              },
              "attribute": "flip-padding"
            },
            {
              "kind": "field",
              "name": "shift",
              "description": "Moves the popover along the axis to keep it in view when clipped.",
              "type": {
                "text": "boolean"
              },
              "attribute": "shift"
            },
            {
              "kind": "field",
              "name": "shiftBoundary",
              "description": "The shift boundary describes clipping element(s) that overflow will be checked relative to when shifting. By\ndefault, the boundary includes overflow ancestors that will cause the element to be clipped. If needed, you can\nchange the boundary by passing a reference to one or more elements to this property.",
              "type": {
                "text": "undefined | Element | Element[]"
              }
            },
            {
              "kind": "field",
              "name": "shiftPadding",
              "description": "The amount of padding, in pixels, to exceed before the shift behavior will occur.",
              "type": {
                "text": "number"
              },
              "attribute": "shift-padding"
            },
            {
              "kind": "field",
              "name": "autoSize",
              "description": "When set, this will cause the popover to automatically resize itself to prevent it from overflowing.",
              "type": {
                "text": "null | 'horizontal' | 'vertical' | 'both'"
              },
              "attribute": "auto-size"
            },
            {
              "kind": "field",
              "name": "sync",
              "description": "Syncs the popover's width or height to that of the anchor element.",
              "type": {
                "text": "null | 'width' | 'height' | 'both'"
              },
              "attribute": "sync"
            },
            {
              "kind": "field",
              "name": "autoSizeBoundary",
              "description": "The auto-size boundary describes clipping element(s) that overflow will be checked relative to when resizing. By\ndefault, the boundary includes overflow ancestors that will cause the element to be clipped. If needed, you can\nchange the boundary by passing a reference to one or more elements to this property.",
              "type": {
                "text": "undefined | Element | Element[]"
              }
            },
            {
              "kind": "field",
              "name": "autoSizePadding",
              "description": "The amount of padding, in pixels, to exceed before the auto-size behavior will occur.",
              "type": {
                "text": "number"
              },
              "attribute": "auto-size-padding"
            },
            {
              "kind": "field",
              "name": "hoverBridge",
              "description": "When a gap exists between the anchor and the popover element, this option will add a \"hover bridge\" that fills the\ngap using an invisible element. This makes listening for events such as `mouseenter` and `mouseleave` more sane\nbecause the pointer never technically leaves the element. The hover bridge will only be drawn when the popover is\nactive.",
              "type": {
                "text": "boolean"
              },
              "attribute": "hover-bridge"
            }
          ],
          "attributes": [
            {
              "name": "placement",
              "description": "The preferred placement of the popover. Note that the actual placement will vary as configured to keep the\npanel inside of the viewport.",
              "type": {
                "text": "'top'\n          | 'top-start'\n          | 'top-end'\n          | 'bottom'\n          | 'bottom-start'\n          | 'bottom-end'\n          | 'right'\n          | 'right-start'\n          | 'right-end'\n          | 'left'\n          | 'left-start'\n          | 'left-end'"
              },
              "fieldName": "placement",
              "attribute": "placement"
            },
            {
              "name": "current-placement",
              "description": "The `currentPlacement` property / `current-placement` attribute are where Floating UI actually positions the popup.",
              "type": {
                "text": "this[\"placement\"] | null"
              },
              "fieldName": "currentPlacement",
              "attribute": "current-placement"
            },
            {
              "name": "strategy",
              "description": "Determines how the popover is positioned. Because you native \"popover\" API uses a fixed strategy, we use it as the default.",
              "type": {
                "text": "Strategy"
              },
              "fieldName": "strategy",
              "attribute": "strategy"
            },
            {
              "name": "distance",
              "description": "The distance in pixels from which to offset along the \"main axis\". Usually its equivalent to offsetY",
              "type": {
                "text": "number"
              },
              "fieldName": "distance",
              "attribute": "distance"
            },
            {
              "name": "skidding",
              "description": "The distance in pixels from which to offset along the \"cross axis\". Usually its equivalent to offsetX.",
              "type": {
                "text": "number"
              },
              "fieldName": "skidding",
              "attribute": "skidding"
            },
            {
              "name": "arrow",
              "description": "Attaches an arrow to the popover. The arrow's size and color can be customized using the `--arrow-size` and\n`--background-color` custom properties. For additional customizations, you can also target the arrow using\n`::part(arrow)` in your stylesheet.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "arrow",
              "attribute": "arrow"
            },
            {
              "name": "arrow-placement",
              "description": "The placement of the arrow. The default is `anchor`, which will align the arrow as close to the center of the\nanchor as possible, considering available space and `arrow-padding`. A value of `start`, `end`, or `center` will\nalign the arrow to the start, end, or center of the popover instead.",
              "type": {
                "text": "'start' | 'end' | 'center' | 'anchor'"
              },
              "fieldName": "arrowPlacement",
              "attribute": "arrow-placement"
            },
            {
              "name": "arrow-padding",
              "description": "The amount of padding between the arrow and the edges of the popover. If the popover has a border-radius, for example,\nthis will prevent it from overflowing the corners.",
              "type": {
                "text": "number"
              },
              "fieldName": "arrowPadding",
              "attribute": "arrow-padding"
            },
            {
              "name": "flip",
              "description": "When set, placement of the popover will flip to the opposite site to keep it in view. You can use\n`flipFallbackPlacements` to further configure how the fallback placement is determined.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "flip",
              "attribute": "flip"
            },
            {
              "name": "flip-fallback-placements",
              "description": "If the preferred placement doesn't fit, popover will be tested in these fallback placements until one fits. Must be a\nstring of any number of placements separated by a space, e.g. \"top bottom left\". If no placement fits, the flip\nfallback strategy will be used instead.",
              "type": {
                "text": "string"
              },
              "fieldName": "flipFallbackPlacements",
              "attribute": "flip-fallback-placements"
            },
            {
              "name": "flip-fallback-strategy",
              "description": "When neither the preferred placement nor the fallback placements fit, this value will be used to determine whether\nthe popover should be positioned using the best available fit based on available space or as it was initially\npreferred.",
              "type": {
                "text": "'best-fit' | 'initial'"
              },
              "fieldName": "flipFallbackStrategy",
              "attribute": "flip-fallback-strategy"
            },
            {
              "name": "flip-padding",
              "description": "The amount of padding, in pixels, to exceed before the flip behavior will occur.",
              "type": {
                "text": "number"
              },
              "fieldName": "flipPadding",
              "attribute": "flip-padding"
            },
            {
              "name": "shift",
              "description": "Moves the popover along the axis to keep it in view when clipped.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "shift",
              "attribute": "shift"
            },
            {
              "name": "shift-padding",
              "description": "The amount of padding, in pixels, to exceed before the shift behavior will occur.",
              "type": {
                "text": "number"
              },
              "fieldName": "shiftPadding",
              "attribute": "shift-padding"
            },
            {
              "name": "auto-size",
              "description": "When set, this will cause the popover to automatically resize itself to prevent it from overflowing.",
              "type": {
                "text": "null | 'horizontal' | 'vertical' | 'both'"
              },
              "fieldName": "autoSize",
              "attribute": "auto-size"
            },
            {
              "name": "sync",
              "description": "Syncs the popover's width or height to that of the anchor element.",
              "type": {
                "text": "null | 'width' | 'height' | 'both'"
              },
              "fieldName": "sync",
              "attribute": "sync"
            },
            {
              "name": "auto-size-padding",
              "description": "The amount of padding, in pixels, to exceed before the auto-size behavior will occur.",
              "type": {
                "text": "number"
              },
              "fieldName": "autoSizePadding",
              "attribute": "auto-size-padding"
            },
            {
              "name": "hover-bridge",
              "description": "When a gap exists between the anchor and the popover element, this option will add a \"hover bridge\" that fills the\ngap using an invisible element. This makes listening for events such as `mouseenter` and `mouseleave` more sane\nbecause the pointer never technically leaves the element. The hover bridge will only be drawn when the popover is\nactive.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "hoverBridge",
              "attribute": "hover-bridge"
            }
          ],
          "parameters": [
            {
              "name": "superclass",
              "type": {
                "text": "T"
              }
            }
          ]
        },
        {
          "kind": "function",
          "name": "AnchoredRegionProperties"
        },
        {
          "kind": "class",
          "description": "",
          "name": "RoleAnchoredRegion",
          "cssProperties": [
            {
              "description": "The size of the arrow. Note that an arrow won't be shown unless the `arrow` attribute is used.",
              "name": "--arrow-size",
              "default": "6px"
            },
            {
              "description": "A read-only custom property that determines the amount of width the popover can be before overflowing. Useful for positioning child elements that need to overflow. This property is only available when using `auto-size`.",
              "name": "--auto-size-available-width"
            },
            {
              "description": "A read-only custom property that determines the amount of height the popover can be before overflowing. Useful for positioning child elements that need to overflow. This property is only available when using `auto-size`.",
              "name": "--auto-size-available-height"
            }
          ],
          "cssParts": [
            {
              "description": "The arrow's container. Avoid setting `top|bottom|left|right` properties, as these values are assigned dynamically as the popover moves. This is most useful for applying a background color to match the popover, and maybe a border or box shadow.",
              "name": "arrow"
            },
            {
              "description": "The popover's container. Useful for setting a background color, box shadow, etc.",
              "name": "popover"
            },
            {
              "description": "The hover bridge element. Only available when the `hover-bridge` option is enabled.",
              "name": "hover-bridge"
            }
          ],
          "slots": [
            {
              "description": "The popover's content.",
              "name": ""
            },
            {
              "description": "The element the popover will be anchored to. If the anchor lives outside of the popover, you can use the `anchor` attribute or property instead.",
              "name": "anchor"
            }
          ],
          "members": [
            {
              "kind": "field",
              "name": "popoverElement",
              "description": "A reference to the internal popover container. Useful for animating and styling the popover with JavaScript.",
              "readonly": true
            },
            {
              "kind": "field",
              "name": "arrowElement",
              "readonly": true
            },
            {
              "kind": "method",
              "name": "reposition",
              "description": "Forces the popover to recalculate and reposition itself."
            },
            {
              "kind": "field",
              "name": "updateHoverBridge"
            },
            {
              "kind": "field",
              "name": "anchor",
              "privacy": "public",
              "type": {
                "text": "null | Element | string | VirtualElement"
              },
              "description": "The element the popover will be anchored to. If the anchor lives outside of the popover, you can provide the anchor\nelement `id`, a DOM element reference, or a `VirtualElement`. If the anchor lives inside the popover, use the\n`anchor` slot instead.",
              "default": "null"
            },
            {
              "kind": "field",
              "name": "active",
              "privacy": "public",
              "type": {
                "text": "boolean"
              },
              "description": "Activates the positioning logic and shows the popover. When this attribute is removed, the positioning logic is torn\ndown and the popover will be hidden.",
              "default": "false",
              "attribute": "active",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "placement",
              "description": "The preferred placement of the popover. Note that the actual placement will vary as configured to keep the\npanel inside of the viewport.",
              "type": {
                "text": "'top'\n          | 'top-start'\n          | 'top-end'\n          | 'bottom'\n          | 'bottom-start'\n          | 'bottom-end'\n          | 'right'\n          | 'right-start'\n          | 'right-end'\n          | 'left'\n          | 'left-start'\n          | 'left-end'"
              },
              "attribute": "placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "currentPlacement",
              "description": "The `currentPlacement` property / `current-placement` attribute are where Floating UI actually positions the popup.",
              "reflects": true,
              "type": {
                "text": "this[\"placement\"] | null"
              },
              "attribute": "current-placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "strategy",
              "description": "Determines how the popover is positioned. Because you native \"popover\" API uses a fixed strategy, we use it as the default.",
              "type": {
                "text": "Strategy"
              },
              "attribute": "strategy",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "distance",
              "description": "The distance in pixels from which to offset along the \"main axis\". Usually its equivalent to offsetY",
              "type": {
                "text": "number"
              },
              "attribute": "distance",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "skidding",
              "description": "The distance in pixels from which to offset along the \"cross axis\". Usually its equivalent to offsetX.",
              "type": {
                "text": "number"
              },
              "attribute": "skidding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "arrow",
              "description": "Attaches an arrow to the popover. The arrow's size and color can be customized using the `--arrow-size` and\n`--background-color` custom properties. For additional customizations, you can also target the arrow using\n`::part(arrow)` in your stylesheet.",
              "type": {
                "text": "boolean"
              },
              "attribute": "arrow",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "arrowPlacement",
              "description": "The placement of the arrow. The default is `anchor`, which will align the arrow as close to the center of the\nanchor as possible, considering available space and `arrow-padding`. A value of `start`, `end`, or `center` will\nalign the arrow to the start, end, or center of the popover instead.",
              "type": {
                "text": "'start' | 'end' | 'center' | 'anchor'"
              },
              "attribute": "arrow-placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "arrowPadding",
              "description": "The amount of padding between the arrow and the edges of the popover. If the popover has a border-radius, for example,\nthis will prevent it from overflowing the corners.",
              "type": {
                "text": "number"
              },
              "attribute": "arrow-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flip",
              "description": "When set, placement of the popover will flip to the opposite site to keep it in view. You can use\n`flipFallbackPlacements` to further configure how the fallback placement is determined.",
              "type": {
                "text": "boolean"
              },
              "attribute": "flip",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flipFallbackPlacements",
              "description": "If the preferred placement doesn't fit, popover will be tested in these fallback placements until one fits. Must be a\nstring of any number of placements separated by a space, e.g. \"top bottom left\". If no placement fits, the flip\nfallback strategy will be used instead.",
              "type": {
                "text": "string"
              },
              "attribute": "flip-fallback-placements",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flipFallbackStrategy",
              "description": "When neither the preferred placement nor the fallback placements fit, this value will be used to determine whether\nthe popover should be positioned using the best available fit based on available space or as it was initially\npreferred.",
              "type": {
                "text": "'best-fit' | 'initial'"
              },
              "attribute": "flip-fallback-strategy",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flipBoundary",
              "description": "The flip boundary describes clipping element(s) that overflow will be checked relative to when flipping. By\ndefault, the boundary includes overflow ancestors that will cause the element to be clipped. If needed, you can\nchange the boundary by passing a reference to one or more elements to this property.",
              "type": {
                "text": "undefined | Element | Element[]"
              },
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flipPadding",
              "description": "The amount of padding, in pixels, to exceed before the flip behavior will occur.",
              "type": {
                "text": "number"
              },
              "attribute": "flip-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "shift",
              "description": "Moves the popover along the axis to keep it in view when clipped.",
              "type": {
                "text": "boolean"
              },
              "attribute": "shift",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "shiftBoundary",
              "description": "The shift boundary describes clipping element(s) that overflow will be checked relative to when shifting. By\ndefault, the boundary includes overflow ancestors that will cause the element to be clipped. If needed, you can\nchange the boundary by passing a reference to one or more elements to this property.",
              "type": {
                "text": "undefined | Element | Element[]"
              },
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "shiftPadding",
              "description": "The amount of padding, in pixels, to exceed before the shift behavior will occur.",
              "type": {
                "text": "number"
              },
              "attribute": "shift-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "autoSize",
              "description": "When set, this will cause the popover to automatically resize itself to prevent it from overflowing.",
              "type": {
                "text": "null | 'horizontal' | 'vertical' | 'both'"
              },
              "attribute": "auto-size",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "sync",
              "description": "Syncs the popover's width or height to that of the anchor element.",
              "type": {
                "text": "null | 'width' | 'height' | 'both'"
              },
              "attribute": "sync",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "autoSizeBoundary",
              "description": "The auto-size boundary describes clipping element(s) that overflow will be checked relative to when resizing. By\ndefault, the boundary includes overflow ancestors that will cause the element to be clipped. If needed, you can\nchange the boundary by passing a reference to one or more elements to this property.",
              "type": {
                "text": "undefined | Element | Element[]"
              },
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "autoSizePadding",
              "description": "The amount of padding, in pixels, to exceed before the auto-size behavior will occur.",
              "type": {
                "text": "number"
              },
              "attribute": "auto-size-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "hoverBridge",
              "description": "When a gap exists between the anchor and the popover element, this option will add a \"hover bridge\" that fills the\ngap using an invisible element. This makes listening for events such as `mouseenter` and `mouseleave` more sane\nbecause the pointer never technically leaves the element. The hover bridge will only be drawn when the popover is\nactive.",
              "type": {
                "text": "boolean"
              },
              "attribute": "hover-bridge",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "dependencies",
              "static": true,
              "type": {
                "text": "Record<string, typeof HTMLElement>"
              },
              "readonly": true,
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "method",
              "name": "debounce",
              "parameters": [
                {
                  "name": "callback",
                  "type": {
                    "text": "(...args: any[]) => any"
                  }
                },
                {
                  "name": "options",
                  "type": {
                    "text": "{ key: any, wait: number }"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "ReturnType<typeof setTimeout>"
                }
              },
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "eventHandler",
              "type": {
                "text": "EventHandler<this>"
              },
              "default": "new EventHandler(this)",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "__debounceMap__",
              "type": {
                "text": "null | Map<any, ReturnType<typeof setTimeout>>"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            }
          ],
          "events": [
            {
              "name": "role-reposition",
              "type": {
                "text": "Event"
              },
              "description": "Emitted when the popover is repositioned. This event can fire a lot, so avoid putting expensive operations in your listener or consider debouncing it."
            }
          ],
          "attributes": [
            {
              "name": "active",
              "type": {
                "text": "boolean"
              },
              "description": "Activates the positioning logic and shows the popover. When this attribute is removed, the positioning logic is torn\ndown and the popover will be hidden.",
              "default": "false",
              "fieldName": "active"
            },
            {
              "name": "placement",
              "description": "The preferred placement of the popover. Note that the actual placement will vary as configured to keep the\npanel inside of the viewport.",
              "type": {
                "text": "'top'\n          | 'top-start'\n          | 'top-end'\n          | 'bottom'\n          | 'bottom-start'\n          | 'bottom-end'\n          | 'right'\n          | 'right-start'\n          | 'right-end'\n          | 'left'\n          | 'left-start'\n          | 'left-end'"
              },
              "fieldName": "placement",
              "attribute": "placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "current-placement",
              "description": "The `currentPlacement` property / `current-placement` attribute are where Floating UI actually positions the popup.",
              "type": {
                "text": "this[\"placement\"] | null"
              },
              "fieldName": "currentPlacement",
              "attribute": "current-placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "strategy",
              "description": "Determines how the popover is positioned. Because you native \"popover\" API uses a fixed strategy, we use it as the default.",
              "type": {
                "text": "Strategy"
              },
              "fieldName": "strategy",
              "attribute": "strategy",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "distance",
              "description": "The distance in pixels from which to offset along the \"main axis\". Usually its equivalent to offsetY",
              "type": {
                "text": "number"
              },
              "fieldName": "distance",
              "attribute": "distance",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "skidding",
              "description": "The distance in pixels from which to offset along the \"cross axis\". Usually its equivalent to offsetX.",
              "type": {
                "text": "number"
              },
              "fieldName": "skidding",
              "attribute": "skidding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "arrow",
              "description": "Attaches an arrow to the popover. The arrow's size and color can be customized using the `--arrow-size` and\n`--background-color` custom properties. For additional customizations, you can also target the arrow using\n`::part(arrow)` in your stylesheet.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "arrow",
              "attribute": "arrow",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "arrow-placement",
              "description": "The placement of the arrow. The default is `anchor`, which will align the arrow as close to the center of the\nanchor as possible, considering available space and `arrow-padding`. A value of `start`, `end`, or `center` will\nalign the arrow to the start, end, or center of the popover instead.",
              "type": {
                "text": "'start' | 'end' | 'center' | 'anchor'"
              },
              "fieldName": "arrowPlacement",
              "attribute": "arrow-placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "arrow-padding",
              "description": "The amount of padding between the arrow and the edges of the popover. If the popover has a border-radius, for example,\nthis will prevent it from overflowing the corners.",
              "type": {
                "text": "number"
              },
              "fieldName": "arrowPadding",
              "attribute": "arrow-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "flip",
              "description": "When set, placement of the popover will flip to the opposite site to keep it in view. You can use\n`flipFallbackPlacements` to further configure how the fallback placement is determined.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "flip",
              "attribute": "flip",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "flip-fallback-placements",
              "description": "If the preferred placement doesn't fit, popover will be tested in these fallback placements until one fits. Must be a\nstring of any number of placements separated by a space, e.g. \"top bottom left\". If no placement fits, the flip\nfallback strategy will be used instead.",
              "type": {
                "text": "string"
              },
              "fieldName": "flipFallbackPlacements",
              "attribute": "flip-fallback-placements",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "flip-fallback-strategy",
              "description": "When neither the preferred placement nor the fallback placements fit, this value will be used to determine whether\nthe popover should be positioned using the best available fit based on available space or as it was initially\npreferred.",
              "type": {
                "text": "'best-fit' | 'initial'"
              },
              "fieldName": "flipFallbackStrategy",
              "attribute": "flip-fallback-strategy",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "flip-padding",
              "description": "The amount of padding, in pixels, to exceed before the flip behavior will occur.",
              "type": {
                "text": "number"
              },
              "fieldName": "flipPadding",
              "attribute": "flip-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "shift",
              "description": "Moves the popover along the axis to keep it in view when clipped.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "shift",
              "attribute": "shift",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "shift-padding",
              "description": "The amount of padding, in pixels, to exceed before the shift behavior will occur.",
              "type": {
                "text": "number"
              },
              "fieldName": "shiftPadding",
              "attribute": "shift-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "auto-size",
              "description": "When set, this will cause the popover to automatically resize itself to prevent it from overflowing.",
              "type": {
                "text": "null | 'horizontal' | 'vertical' | 'both'"
              },
              "fieldName": "autoSize",
              "attribute": "auto-size",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "sync",
              "description": "Syncs the popover's width or height to that of the anchor element.",
              "type": {
                "text": "null | 'width' | 'height' | 'both'"
              },
              "fieldName": "sync",
              "attribute": "sync",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "auto-size-padding",
              "description": "The amount of padding, in pixels, to exceed before the auto-size behavior will occur.",
              "type": {
                "text": "number"
              },
              "fieldName": "autoSizePadding",
              "attribute": "auto-size-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "hover-bridge",
              "description": "When a gap exists between the anchor and the popover element, this option will add a \"hover bridge\" that fills the\ngap using an invisible element. This makes listening for events such as `mouseenter` and `mouseleave` more sane\nbecause the pointer never technically leaves the element. The hover bridge will only be drawn when the popover is\nactive.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "hoverBridge",
              "attribute": "hover-bridge",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            }
          ],
          "mixins": [
            {
              "name": "AnchoredRegionMixin",
              "module": "exports/anchored-region/anchored-region.js"
            }
          ],
          "superclass": {
            "name": "BaseElement",
            "module": "/exports/base-element.js"
          },
          "summary": "Popup is a utility that lets you declaratively anchor \"popover\" containers to another element."
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "AnchoredRegionMixin",
          "declaration": {
            "name": "AnchoredRegionMixin",
            "module": "exports/anchored-region/anchored-region.js"
          }
        },
        {
          "kind": "js",
          "name": "AnchoredRegionProperties",
          "declaration": {
            "name": "AnchoredRegionProperties",
            "module": "exports/anchored-region/anchored-region.js"
          }
        },
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "RoleAnchoredRegion",
            "module": "exports/anchored-region/anchored-region.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/combobox/combobox-register.js",
      "declarations": [],
      "exports": [
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "RoleCombobox",
            "module": "exports/combobox/combobox-register.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/combobox/combobox.js",
      "declarations": [
        {
          "kind": "class",
          "description": "A listbox following the W3C Listbox pattern.\n\n<https://www.w3.org/WAI/ARIA/apg/patterns/listbox/>\n\n\n`Single-select` listbox uses the \"select follows focus\" model.\n\n\n`Multi-select` listbox implements the keyboard recommendations here: <https://www.w3.org/WAI/ARIA/apg/patterns/listbox/#keyboard_interaction>\n\n  - <kbd>Shift + Down Arrow</kbd>: Moves focus to and toggles the selected state of the next option.\n  - <kbd>Shift + Up Arrow</kbd>: Moves focus to and toggles the selected state of the previous option.\n  - <kbd>Shift + Space</kbd>: Selects contiguous items from the most recently selected item to the focused item.\n  - <kbd>Control + Shift + Home</kbd>: Selects the focused option and all options up to the first option. Optionally, moves focus to the first option.\n  - <kbd>Control + Shift + End</kbd>: Selects the focused option and all options down to the last option.\n  - <kbd>Control + a</kbd>: Selects all\n\n  The currently hovered / focus `<role-option>` has `[aria-current=\"true\"]`\n\n  The currently selected `<role-option>` has `[aria-selected=\"true\"]`",
          "name": "RoleCombobox",
          "members": [
            {
              "kind": "field",
              "name": "baseName",
              "type": {
                "text": "string"
              },
              "static": true,
              "default": "\"role-combobox\""
            },
            {
              "kind": "field",
              "name": "shadowRootOptions",
              "type": {
                "text": "object"
              },
              "static": true,
              "default": "{...LitElement.shadowRootOptions, delegatesFocus: true }"
            },
            {
              "kind": "field",
              "name": "dependencies",
              "static": true,
              "type": {
                "text": "Record<string, typeof HTMLElement>"
              },
              "readonly": true,
              "default": "{ 'role-anchored-region': RoleAnchoredRegion }",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "method",
              "name": "focus",
              "parameters": [
                {
                  "name": "args"
                }
              ],
              "type": {
                "text": "HTMLElement[\"focus\"]"
              }
            },
            {
              "kind": "method",
              "name": "handleInput",
              "parameters": [
                {
                  "name": "event",
                  "type": {
                    "text": "InputEvent"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "splitValue",
              "parameters": [
                {
                  "name": "value",
                  "type": {
                    "text": "string"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "handleMultipleEditableInput",
              "parameters": [
                {
                  "name": "event",
                  "type": {
                    "text": "InputEvent"
                  }
                },
                {
                  "name": "triggerElement",
                  "type": {
                    "text": "HTMLButtonElement | HTMLInputElement"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "__shouldSelectSuggestedOption",
              "parameters": [
                {
                  "name": "finalString",
                  "type": {
                    "text": "string"
                  }
                },
                {
                  "name": "event",
                  "type": {
                    "text": "InputEvent"
                  }
                }
              ],
              "privacy": "private"
            },
            {
              "kind": "method",
              "name": "__findSuggestedOption",
              "parameters": [
                {
                  "name": "finalString",
                  "type": {
                    "text": "string"
                  }
                },
                {
                  "name": "event",
                  "type": {
                    "text": "InputEvent"
                  }
                },
                {
                  "name": "newSelectedOptions",
                  "type": {
                    "text": "typeof this.selectedOptions"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "__handleConfirmInput",
              "parameters": [
                {
                  "name": "event",
                  "type": {
                    "text": "InputEvent"
                  }
                },
                {
                  "name": "triggerElement",
                  "type": {
                    "text": "HTMLButtonElement | HTMLInputElement"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "__handleFreeflowInput",
              "parameters": [
                {
                  "name": "event",
                  "type": {
                    "text": "InputEvent"
                  }
                },
                {
                  "name": "triggerElement",
                  "type": {
                    "text": "HTMLButtonElement | HTMLInputElement"
                  }
                }
              ],
              "privacy": "private"
            },
            {
              "kind": "method",
              "name": "handleSingleEditableInput",
              "parameters": [
                {
                  "name": "event",
                  "type": {
                    "text": "InputEvent"
                  }
                },
                {
                  "name": "triggerElement",
                  "type": {
                    "text": "typeof this.triggerElement"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "optionElementToOptionObject",
              "parameters": [
                {
                  "name": "el",
                  "type": {
                    "text": "RoleOption"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "OptionObject"
                }
              }
            },
            {
              "kind": "method",
              "name": "handleOptionFocus",
              "parameters": [
                {
                  "name": "event",
                  "type": {
                    "text": "{target: null | RoleOption}"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "handleInputClick",
              "parameters": [
                {
                  "name": "e",
                  "type": {
                    "text": "Event"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "handleOutsideClick",
              "parameters": [
                {
                  "name": "e",
                  "type": {
                    "text": "Event"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "assignRandomId",
              "parameters": [
                {
                  "name": "el",
                  "type": {
                    "text": "HTMLElement"
                  }
                },
                {
                  "name": "id",
                  "default": "uuidv4()"
                }
              ],
              "description": "Users dont always provide ids on elements, and we need to make sure the id isn't already taken."
            },
            {
              "kind": "field",
              "name": "listbox",
              "readonly": true
            },
            {
              "kind": "field",
              "name": "isEditable",
              "readonly": true
            },
            {
              "kind": "method",
              "name": "updateListboxElement",
              "description": "Adds proper attributes to the slotted listbox element"
            },
            {
              "kind": "method",
              "name": "handleInputFocus",
              "parameters": [
                {
                  "name": "e",
                  "type": {
                    "text": "Event"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "updateTriggerElement",
              "description": "Adds proper attributes to the slotted input element"
            },
            {
              "kind": "method",
              "name": "renderSelectedOptions"
            },
            {
              "kind": "field",
              "name": "shouldShowEmptyResults",
              "readonly": true
            },
            {
              "kind": "method",
              "name": "formResetCallback"
            },
            {
              "kind": "field",
              "name": "isEditableMultipleCombobox",
              "return": {
                "type": {
                  "text": "boolean"
                }
              },
              "readonly": true
            },
            {
              "kind": "method",
              "name": "setCurrent",
              "parameters": [
                {
                  "name": "option",
                  "type": {
                    "text": "OptionObject"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "removeCurrent",
              "parameters": [
                {
                  "name": "option",
                  "type": {
                    "text": "OptionObject"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "findOptionElement",
              "parameters": [
                {
                  "name": "option",
                  "type": {
                    "text": "OptionObject"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "RoleOption | null"
                }
              }
            },
            {
              "kind": "method",
              "name": "handleOptionClick",
              "parameters": [
                {
                  "name": "evt",
                  "type": {
                    "text": "PointerEvent"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "handleOptionHover",
              "parameters": [
                {
                  "name": "evt",
                  "type": {
                    "text": "Event"
                  }
                }
              ]
            },
            {
              "kind": "field",
              "name": "currentOptionIndex",
              "readonly": true
            },
            {
              "kind": "field",
              "name": "currentFocusableOptionIndex",
              "readonly": true
            },
            {
              "kind": "method",
              "name": "handleKeyUp",
              "parameters": [
                {
                  "name": "evt",
                  "type": {
                    "text": "KeyboardEvent"
                  }
                }
              ],
              "description": "Reset range when shiftKey goes up"
            },
            {
              "kind": "method",
              "name": "handleKeyDown",
              "parameters": [
                {
                  "name": "evt",
                  "type": {
                    "text": "KeyboardEvent"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "selectFromClosestSelectedToCurrent",
              "description": "Finds the closest selected option prior to the current option"
            },
            {
              "kind": "method",
              "name": "selectFromRangeStartToCurrent"
            },
            {
              "kind": "method",
              "name": "selectRange",
              "parameters": [
                {
                  "name": "{ from, to }"
                },
                {
                  "name": "options",
                  "type": {
                    "text": "Range"
                  }
                }
              ],
              "description": "Selects all options in a range and deselects all options not in the range"
            },
            {
              "kind": "method",
              "name": "selectFromStartToCurrent",
              "parameters": [
                {
                  "name": "startIndex",
                  "default": "0",
                  "optional": true,
                  "type": {
                    "text": "number"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "selectFromCurrentToEnd",
              "parameters": [
                {
                  "name": "endIndex",
                  "default": "this.options.length - 1",
                  "optional": true,
                  "type": {
                    "text": "number"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "escapeRegexChars",
              "parameters": [
                {
                  "name": "str",
                  "type": {
                    "text": "string"
                  }
                }
              ],
              "description": "Escape characters for regex matching."
            },
            {
              "kind": "method",
              "name": "stringToRegex",
              "parameters": [
                {
                  "name": "str",
                  "type": {
                    "text": "string"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "focusElementFromSearchBuffer"
            },
            {
              "kind": "method",
              "name": "select",
              "parameters": [
                {
                  "name": "option",
                  "type": {
                    "text": "OptionObject"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "deselect",
              "parameters": [
                {
                  "name": "option",
                  "type": {
                    "text": "OptionObject"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "selectAll",
              "description": "Mark every element with [aria-selected=\"true\"]"
            },
            {
              "kind": "method",
              "name": "deselectAll",
              "parameters": [
                {
                  "name": "updateOptions",
                  "default": "true"
                }
              ],
              "description": "Mark every element with [aria-selected=\"false\"]"
            },
            {
              "kind": "method",
              "name": "toggleSelected",
              "parameters": [
                {
                  "name": "option",
                  "type": {
                    "text": "OptionObject"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "focusCurrent"
            },
            {
              "kind": "field",
              "name": "focusableOptions",
              "readonly": true
            },
            {
              "kind": "method",
              "name": "focusAt",
              "parameters": [
                {
                  "name": "index",
                  "type": {
                    "text": "number"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "focusNext"
            },
            {
              "kind": "method",
              "name": "focusPrevious"
            },
            {
              "kind": "method",
              "name": "focusFirst"
            },
            {
              "kind": "method",
              "name": "focusLast"
            },
            {
              "kind": "method",
              "name": "scrollOptionIntoView",
              "parameters": [
                {
                  "name": "selectedOption",
                  "type": {
                    "text": "OptionObject"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "void"
                }
              }
            },
            {
              "kind": "method",
              "name": "scrollOptionElementIntoView",
              "parameters": [
                {
                  "name": "optionElement",
                  "type": {
                    "text": "HTMLElement"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "void"
                }
              }
            },
            {
              "kind": "method",
              "name": "isSelected",
              "parameters": [
                {
                  "name": "option",
                  "type": {
                    "text": "OptionObject"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "boolean"
                }
              }
            },
            {
              "kind": "field",
              "name": "selectableOptions",
              "return": {
                "type": {
                  "text": "NodeListOf<HTMLOptionElement | RoleOption>"
                }
              },
              "readonly": true
            },
            {
              "kind": "field",
              "name": "completionSelected",
              "description": "\"completionSelected\" is determined by if the user has an autosuggestion in the `<input>`.",
              "readonly": true
            },
            {
              "kind": "method",
              "name": "updateOptions"
            },
            {
              "kind": "field",
              "name": "multipleFormDataAndStringValue",
              "readonly": true
            },
            {
              "kind": "method",
              "name": "updateMultipleValue",
              "parameters": [
                {
                  "name": "force",
                  "default": "false",
                  "description": "whether or not to force update a new value",
                  "optional": true,
                  "type": {
                    "text": "boolean"
                  }
                }
              ],
              "description": "Updates formData / combobox.value"
            },
            {
              "kind": "method",
              "name": "updateTriggerElementTextContentAndValue",
              "parameters": [
                {
                  "name": "str",
                  "type": {
                    "text": "string"
                  }
                }
              ]
            },
            {
              "kind": "field",
              "name": "triggerElement",
              "type": {
                "text": "HTMLButtonElement | HTMLInputElement | null"
              },
              "default": "null"
            },
            {
              "kind": "field",
              "name": "__listboxId"
            },
            {
              "kind": "field",
              "name": "__confirmOptionId",
              "description": "Used to inject a `<role-option>` into the Light DOM for `multiple-selection-type=\"confirm\"`"
            },
            {
              "kind": "field",
              "name": "autocomplete",
              "privacy": "public",
              "type": {
                "text": "'' | \"off\" | \"inline\" | \"list\" | \"both\""
              },
              "description": "Any autocompletes of type `\"off\"`, `\"inline\"`, `\"list\"`, or `\"both\"` will automatically make the triggerElement editable.",
              "default": "''",
              "attribute": "autocomplete"
            },
            {
              "kind": "field",
              "name": "placement",
              "description": "The preferred placement of the popover. Note that the actual placement will vary as configured to keep the\npanel inside of the viewport.",
              "type": {
                "text": "'top'\n          | 'top-start'\n          | 'top-end'\n          | 'bottom'\n          | 'bottom-start'\n          | 'bottom-end'\n          | 'right'\n          | 'right-start'\n          | 'right-end'\n          | 'left'\n          | 'left-start'\n          | 'left-end'"
              },
              "attribute": "placement",
              "default": "\"bottom\"",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "distance",
              "description": "The distance in pixels from which to offset along the \"main axis\". Usually its equivalent to offsetY",
              "type": {
                "text": "number"
              },
              "attribute": "distance",
              "default": "6",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "multipleSelectionType",
              "privacy": "public",
              "type": {
                "text": "\"freeflow\" | \"confirm\""
              },
              "description": "If set to \"freeflow\", it will be one single text input with delimited values.\n  If set to \"confirm\", you will only enter 1 option at a time, and then need to confirm selection, and then the input will clear, and then you will add another selection.",
              "default": "\"freeflow\"",
              "attribute": "multiple-selection-type"
            },
            {
              "kind": "field",
              "name": "editable",
              "privacy": "public",
              "type": {
                "text": "boolean"
              },
              "description": "If true, the `<input>` element provided is not treated as readonly, and rather as an editable input. This can be omitted\n if you use any of the possible `autocomplete` attributes. Do not use this to check if the combobox is editable.\n instead, use `this.isEditable` to check if the triggerElement is editable.",
              "default": "false",
              "attribute": "editable"
            },
            {
              "kind": "field",
              "name": "delimiter",
              "privacy": "public",
              "type": {
                "text": "string"
              },
              "description": "Used for multiple select comboboxes that use `value-type=\"string\"`. The default is a comma.",
              "default": "','",
              "attribute": "delimiter"
            },
            {
              "kind": "field",
              "name": "spacer",
              "privacy": "public",
              "type": {
                "text": "string"
              },
              "description": "Used for multiple select comboboxes that use `value-type=\"string\"`. The default is a space.",
              "default": "\" \"",
              "attribute": "spacer"
            },
            {
              "kind": "field",
              "name": "selectedOptions",
              "privacy": "public",
              "type": {
                "text": "OptionObject[]"
              },
              "default": "[]"
            },
            {
              "kind": "field",
              "name": "options",
              "privacy": "public",
              "type": {
                "text": "OptionObject[]"
              },
              "default": "[]"
            },
            {
              "kind": "field",
              "name": "currentOption",
              "privacy": "public",
              "type": {
                "text": "null | OptionObject"
              },
              "default": "null"
            },
            {
              "kind": "field",
              "name": "expanded",
              "privacy": "public",
              "type": {
                "text": "boolean"
              },
              "default": "false",
              "attribute": "expanded"
            },
            {
              "kind": "field",
              "name": "multiple",
              "privacy": "public",
              "type": {
                "text": "boolean"
              },
              "description": "Whether to allow multiple selections.",
              "default": "false",
              "attribute": "multiple"
            },
            {
              "kind": "field",
              "name": "value",
              "type": {
                "text": "null | FormData | string"
              },
              "default": "null"
            },
            {
              "kind": "field",
              "name": "__rangeStartOption",
              "privacy": "public",
              "type": {
                "text": "null | OptionObject"
              },
              "description": "Used internally for range selections",
              "default": "null"
            },
            {
              "kind": "field",
              "name": "wrapSelection",
              "privacy": "public",
              "type": {
                "text": "boolean"
              },
              "default": "false",
              "attribute": "wrap-selection"
            },
            {
              "kind": "field",
              "name": "filterResults",
              "privacy": "public",
              "type": {
                "text": "boolean"
              },
              "description": "Whether or not to filter results based on what is typed into the combobox.",
              "default": "false",
              "attribute": "filter-results"
            },
            {
              "kind": "field",
              "name": "role",
              "type": {
                "text": "string"
              },
              "default": "\"presentation\""
            },
            {
              "kind": "field",
              "name": "label",
              "type": {
                "text": "string"
              },
              "default": "\"\""
            },
            {
              "kind": "field",
              "name": "showEmptyResults",
              "privacy": "public",
              "type": {
                "text": "boolean"
              },
              "description": "If true, or `show-empty-results` attribute is present, it will show the \"no-results-found\" slot.",
              "default": "false",
              "attribute": "show-empty-results"
            },
            {
              "kind": "field",
              "name": "searchBufferDelay",
              "privacy": "public",
              "type": {
                "text": "number"
              },
              "description": "Delay before the search buffer returns to an empty string",
              "default": "600",
              "attribute": "search-buffer-delay",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "valueType",
              "privacy": "public",
              "type": {
                "text": "\"formdata\" | \"string\""
              },
              "description": "Used for multiple selects. You can either have a string, or submit as multiple parameters in FormData\n  like a native `<select>`. The default is a \"string\".",
              "default": "\"string\"",
              "attribute": "value-type"
            },
            {
              "kind": "field",
              "name": "attributeFilter",
              "type": {
                "text": "array"
              },
              "default": "[ \"aria-current\", \"selected\", \"current\", \"aria-selected\", \"role\", ]"
            },
            {
              "kind": "field",
              "name": "optionObserver",
              "description": "Monitors its DOM for new nodes and assigns them to `this.options`",
              "type": {
                "text": "MutationObserver"
              },
              "default": "new MutationObserver((mutations) => { for (const _mutation of mutations) { this.debounce(() => { this.updateOptions(); }, { wait: 10, key: this.updateOptions, }); // We really don't care about the mutations, we just need to know if things are updating. break; } })"
            },
            {
              "kind": "field",
              "name": "defaultValue",
              "privacy": "public",
              "attribute": "value",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "_hasFocused",
              "privacy": "public"
            },
            {
              "kind": "field",
              "name": "_searchBuffer",
              "privacy": "public",
              "ignore": true,
              "type": {
                "text": "string"
              },
              "description": "Internal buffer for searching the listbox.",
              "default": "\"\""
            },
            {
              "kind": "field",
              "name": "_searchBufferDebounce",
              "privacy": "public",
              "ignore": true,
              "type": {
                "text": "null | ReturnType<typeof setTimeout>"
              },
              "description": "timeoutId to clear the search buffer",
              "default": "null"
            },
            {
              "kind": "field",
              "name": "currentPlacement",
              "description": "The `currentPlacement` property / `current-placement` attribute are where Floating UI actually positions the popup.",
              "reflects": true,
              "type": {
                "text": "this[\"placement\"] | null"
              },
              "attribute": "current-placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "strategy",
              "description": "Determines how the popover is positioned. Because you native \"popover\" API uses a fixed strategy, we use it as the default.",
              "type": {
                "text": "Strategy"
              },
              "attribute": "strategy",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "skidding",
              "description": "The distance in pixels from which to offset along the \"cross axis\". Usually its equivalent to offsetX.",
              "type": {
                "text": "number"
              },
              "attribute": "skidding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "arrow",
              "description": "Attaches an arrow to the popover. The arrow's size and color can be customized using the `--arrow-size` and\n`--background-color` custom properties. For additional customizations, you can also target the arrow using\n`::part(arrow)` in your stylesheet.",
              "type": {
                "text": "boolean"
              },
              "attribute": "arrow",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "arrowPlacement",
              "description": "The placement of the arrow. The default is `anchor`, which will align the arrow as close to the center of the\nanchor as possible, considering available space and `arrow-padding`. A value of `start`, `end`, or `center` will\nalign the arrow to the start, end, or center of the popover instead.",
              "type": {
                "text": "'start' | 'end' | 'center' | 'anchor'"
              },
              "attribute": "arrow-placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "arrowPadding",
              "description": "The amount of padding between the arrow and the edges of the popover. If the popover has a border-radius, for example,\nthis will prevent it from overflowing the corners.",
              "type": {
                "text": "number"
              },
              "attribute": "arrow-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flip",
              "description": "When set, placement of the popover will flip to the opposite site to keep it in view. You can use\n`flipFallbackPlacements` to further configure how the fallback placement is determined.",
              "type": {
                "text": "boolean"
              },
              "attribute": "flip",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flipFallbackPlacements",
              "description": "If the preferred placement doesn't fit, popover will be tested in these fallback placements until one fits. Must be a\nstring of any number of placements separated by a space, e.g. \"top bottom left\". If no placement fits, the flip\nfallback strategy will be used instead.",
              "type": {
                "text": "string"
              },
              "attribute": "flip-fallback-placements",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flipFallbackStrategy",
              "description": "When neither the preferred placement nor the fallback placements fit, this value will be used to determine whether\nthe popover should be positioned using the best available fit based on available space or as it was initially\npreferred.",
              "type": {
                "text": "'best-fit' | 'initial'"
              },
              "attribute": "flip-fallback-strategy",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flipBoundary",
              "description": "The flip boundary describes clipping element(s) that overflow will be checked relative to when flipping. By\ndefault, the boundary includes overflow ancestors that will cause the element to be clipped. If needed, you can\nchange the boundary by passing a reference to one or more elements to this property.",
              "type": {
                "text": "undefined | Element | Element[]"
              },
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flipPadding",
              "description": "The amount of padding, in pixels, to exceed before the flip behavior will occur.",
              "type": {
                "text": "number"
              },
              "attribute": "flip-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "shift",
              "description": "Moves the popover along the axis to keep it in view when clipped.",
              "type": {
                "text": "boolean"
              },
              "attribute": "shift",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "shiftBoundary",
              "description": "The shift boundary describes clipping element(s) that overflow will be checked relative to when shifting. By\ndefault, the boundary includes overflow ancestors that will cause the element to be clipped. If needed, you can\nchange the boundary by passing a reference to one or more elements to this property.",
              "type": {
                "text": "undefined | Element | Element[]"
              },
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "shiftPadding",
              "description": "The amount of padding, in pixels, to exceed before the shift behavior will occur.",
              "type": {
                "text": "number"
              },
              "attribute": "shift-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "autoSize",
              "description": "When set, this will cause the popover to automatically resize itself to prevent it from overflowing.",
              "type": {
                "text": "null | 'horizontal' | 'vertical' | 'both'"
              },
              "attribute": "auto-size",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "sync",
              "description": "Syncs the popover's width or height to that of the anchor element.",
              "type": {
                "text": "null | 'width' | 'height' | 'both'"
              },
              "attribute": "sync",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "autoSizeBoundary",
              "description": "The auto-size boundary describes clipping element(s) that overflow will be checked relative to when resizing. By\ndefault, the boundary includes overflow ancestors that will cause the element to be clipped. If needed, you can\nchange the boundary by passing a reference to one or more elements to this property.",
              "type": {
                "text": "undefined | Element | Element[]"
              },
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "autoSizePadding",
              "description": "The amount of padding, in pixels, to exceed before the auto-size behavior will occur.",
              "type": {
                "text": "number"
              },
              "attribute": "auto-size-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "hoverBridge",
              "description": "When a gap exists between the anchor and the popover element, this option will add a \"hover bridge\" that fills the\ngap using an invisible element. This makes listening for events such as `mouseenter` and `mouseleave` more sane\nbecause the pointer never technically leaves the element. The hover bridge will only be drawn when the popover is\nactive.",
              "type": {
                "text": "boolean"
              },
              "attribute": "hover-bridge",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "method",
              "name": "debounce",
              "parameters": [
                {
                  "name": "callback",
                  "type": {
                    "text": "(...args: any[]) => any"
                  }
                },
                {
                  "name": "options",
                  "type": {
                    "text": "{ key: any, wait: number }"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "ReturnType<typeof setTimeout>"
                }
              },
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "eventHandler",
              "type": {
                "text": "EventHandler<this>"
              },
              "default": "new EventHandler(this)",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "__debounceMap__",
              "type": {
                "text": "null | Map<any, ReturnType<typeof setTimeout>>"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            }
          ],
          "events": [
            {
              "name": "change",
              "type": {
                "text": "Event"
              }
            },
            {
              "name": "input",
              "type": {
                "text": "Event"
              }
            }
          ],
          "attributes": [
            {
              "name": "expanded",
              "type": {
                "text": "boolean"
              },
              "default": "false",
              "fieldName": "expanded"
            },
            {
              "name": "autocomplete",
              "type": {
                "text": "'' | \"off\" | \"inline\" | \"list\" | \"both\""
              },
              "description": "Any autocompletes of type `\"off\"`, `\"inline\"`, `\"list\"`, or `\"both\"` will automatically make the triggerElement editable.",
              "default": "''",
              "fieldName": "autocomplete"
            },
            {
              "name": "multiple",
              "type": {
                "text": "boolean"
              },
              "description": "Whether to allow multiple selections.",
              "default": "false",
              "fieldName": "multiple"
            },
            {
              "name": "value",
              "fieldName": "defaultValue"
            },
            {
              "name": "wrap-selection",
              "type": {
                "text": "boolean"
              },
              "default": "false",
              "fieldName": "wrapSelection"
            },
            {
              "name": "editable",
              "type": {
                "text": "boolean"
              },
              "description": "If true, the `<input>` element provided is not treated as readonly, and rather as an editable input. This can be omitted\n if you use any of the possible `autocomplete` attributes. Do not use this to check if the combobox is editable.\n instead, use `this.isEditable` to check if the triggerElement is editable.",
              "default": "false",
              "fieldName": "editable"
            },
            {
              "name": "filter-results",
              "type": {
                "text": "boolean"
              },
              "description": "Whether or not to filter results based on what is typed into the combobox.",
              "default": "false",
              "fieldName": "filterResults"
            },
            {
              "name": "search-buffer-delay",
              "type": {
                "text": "number"
              },
              "description": "Delay before the search buffer returns to an empty string",
              "default": "600",
              "fieldName": "searchBufferDelay"
            },
            {
              "name": "value-type",
              "type": {
                "text": "\"formdata\" | \"string\""
              },
              "description": "Used for multiple selects. You can either have a string, or submit as multiple parameters in FormData\n  like a native `<select>`. The default is a \"string\".",
              "default": "\"string\"",
              "fieldName": "valueType"
            },
            {
              "name": "delimiter",
              "type": {
                "text": "string"
              },
              "description": "Used for multiple select comboboxes that use `value-type=\"string\"`. The default is a comma.",
              "default": "','",
              "fieldName": "delimiter"
            },
            {
              "name": "spacer",
              "type": {
                "text": "string"
              },
              "description": "Used for multiple select comboboxes that use `value-type=\"string\"`. The default is a space.",
              "default": "\" \"",
              "fieldName": "spacer"
            },
            {
              "name": "show-empty-results",
              "type": {
                "text": "boolean"
              },
              "description": "If true, or `show-empty-results` attribute is present, it will show the \"no-results-found\" slot.",
              "default": "false",
              "fieldName": "showEmptyResults"
            },
            {
              "name": "multiple-selection-type",
              "type": {
                "text": "\"freeflow\" | \"confirm\""
              },
              "description": "If set to \"freeflow\", it will be one single text input with delimited values.\n  If set to \"confirm\", you will only enter 1 option at a time, and then need to confirm selection, and then the input will clear, and then you will add another selection.",
              "default": "\"freeflow\"",
              "fieldName": "multipleSelectionType"
            },
            {
              "name": "placement",
              "description": "The preferred placement of the popover. Note that the actual placement will vary as configured to keep the\npanel inside of the viewport.",
              "type": {
                "text": "'top'\n          | 'top-start'\n          | 'top-end'\n          | 'bottom'\n          | 'bottom-start'\n          | 'bottom-end'\n          | 'right'\n          | 'right-start'\n          | 'right-end'\n          | 'left'\n          | 'left-start'\n          | 'left-end'"
              },
              "fieldName": "placement",
              "attribute": "placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "current-placement",
              "description": "The `currentPlacement` property / `current-placement` attribute are where Floating UI actually positions the popup.",
              "type": {
                "text": "this[\"placement\"] | null"
              },
              "fieldName": "currentPlacement",
              "attribute": "current-placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "strategy",
              "description": "Determines how the popover is positioned. Because you native \"popover\" API uses a fixed strategy, we use it as the default.",
              "type": {
                "text": "Strategy"
              },
              "fieldName": "strategy",
              "attribute": "strategy",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "distance",
              "description": "The distance in pixels from which to offset along the \"main axis\". Usually its equivalent to offsetY",
              "type": {
                "text": "number"
              },
              "fieldName": "distance",
              "attribute": "distance",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "skidding",
              "description": "The distance in pixels from which to offset along the \"cross axis\". Usually its equivalent to offsetX.",
              "type": {
                "text": "number"
              },
              "fieldName": "skidding",
              "attribute": "skidding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "arrow",
              "description": "Attaches an arrow to the popover. The arrow's size and color can be customized using the `--arrow-size` and\n`--background-color` custom properties. For additional customizations, you can also target the arrow using\n`::part(arrow)` in your stylesheet.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "arrow",
              "attribute": "arrow",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "arrow-placement",
              "description": "The placement of the arrow. The default is `anchor`, which will align the arrow as close to the center of the\nanchor as possible, considering available space and `arrow-padding`. A value of `start`, `end`, or `center` will\nalign the arrow to the start, end, or center of the popover instead.",
              "type": {
                "text": "'start' | 'end' | 'center' | 'anchor'"
              },
              "fieldName": "arrowPlacement",
              "attribute": "arrow-placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "arrow-padding",
              "description": "The amount of padding between the arrow and the edges of the popover. If the popover has a border-radius, for example,\nthis will prevent it from overflowing the corners.",
              "type": {
                "text": "number"
              },
              "fieldName": "arrowPadding",
              "attribute": "arrow-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "flip",
              "description": "When set, placement of the popover will flip to the opposite site to keep it in view. You can use\n`flipFallbackPlacements` to further configure how the fallback placement is determined.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "flip",
              "attribute": "flip",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "flip-fallback-placements",
              "description": "If the preferred placement doesn't fit, popover will be tested in these fallback placements until one fits. Must be a\nstring of any number of placements separated by a space, e.g. \"top bottom left\". If no placement fits, the flip\nfallback strategy will be used instead.",
              "type": {
                "text": "string"
              },
              "fieldName": "flipFallbackPlacements",
              "attribute": "flip-fallback-placements",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "flip-fallback-strategy",
              "description": "When neither the preferred placement nor the fallback placements fit, this value will be used to determine whether\nthe popover should be positioned using the best available fit based on available space or as it was initially\npreferred.",
              "type": {
                "text": "'best-fit' | 'initial'"
              },
              "fieldName": "flipFallbackStrategy",
              "attribute": "flip-fallback-strategy",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "flip-padding",
              "description": "The amount of padding, in pixels, to exceed before the flip behavior will occur.",
              "type": {
                "text": "number"
              },
              "fieldName": "flipPadding",
              "attribute": "flip-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "shift",
              "description": "Moves the popover along the axis to keep it in view when clipped.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "shift",
              "attribute": "shift",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "shift-padding",
              "description": "The amount of padding, in pixels, to exceed before the shift behavior will occur.",
              "type": {
                "text": "number"
              },
              "fieldName": "shiftPadding",
              "attribute": "shift-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "auto-size",
              "description": "When set, this will cause the popover to automatically resize itself to prevent it from overflowing.",
              "type": {
                "text": "null | 'horizontal' | 'vertical' | 'both'"
              },
              "fieldName": "autoSize",
              "attribute": "auto-size",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "sync",
              "description": "Syncs the popover's width or height to that of the anchor element.",
              "type": {
                "text": "null | 'width' | 'height' | 'both'"
              },
              "fieldName": "sync",
              "attribute": "sync",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "auto-size-padding",
              "description": "The amount of padding, in pixels, to exceed before the auto-size behavior will occur.",
              "type": {
                "text": "number"
              },
              "fieldName": "autoSizePadding",
              "attribute": "auto-size-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "hover-bridge",
              "description": "When a gap exists between the anchor and the popover element, this option will add a \"hover bridge\" that fills the\ngap using an invisible element. This makes listening for events such as `mouseenter` and `mouseleave` more sane\nbecause the pointer never technically leaves the element. The hover bridge will only be drawn when the popover is\nactive.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "hoverBridge",
              "attribute": "hover-bridge",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            }
          ],
          "mixins": [
            {
              "name": "AnchoredRegionMixin",
              "module": "/exports/anchored-region/anchored-region.js"
            },
            {
              "name": "LitFormAssociatedMixin",
              "package": "form-associated-helpers/exports/mixins/lit-form-associated-mixin.js"
            }
          ],
          "superclass": {
            "name": "BaseElement",
            "module": "/exports/base-element.js"
          },
          "tagName": "role-combobox",
          "customElement": true
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "RoleCombobox",
            "module": "exports/combobox/combobox.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/events/base-event.js",
      "declarations": [
        {
          "kind": "class",
          "description": "",
          "name": "BaseEvent",
          "superclass": {
            "name": "Event",
            "module": "exports/events/base-event.js"
          }
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "BaseEvent",
          "declaration": {
            "name": "BaseEvent",
            "module": "exports/events/base-event.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/events/selected-event.js",
      "declarations": [
        {
          "kind": "class",
          "description": "",
          "name": "SelectedEvent",
          "members": [
            {
              "kind": "field",
              "name": "selectedElement",
              "type": {
                "text": "null | RoleOption"
              }
            },
            {
              "kind": "field",
              "name": "selectedOption",
              "type": {
                "text": "null | OptionObject"
              }
            }
          ],
          "superclass": {
            "name": "BaseEvent",
            "module": "/exports/events/base-event.js"
          }
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "SelectedEvent",
          "declaration": {
            "name": "SelectedEvent",
            "module": "exports/events/selected-event.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/listbox/listbox-register.js",
      "declarations": [],
      "exports": [
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "RoleListbox",
            "module": "exports/listbox/listbox-register.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/listbox/listbox.js",
      "declarations": [
        {
          "kind": "class",
          "description": "A listbox following the APG Listbox pattern.\n\n<https://www.w3.org/WAI/ARIA/apg/patterns/listbox/>\n\n\n`Single-select` listbox uses the \"select follows focus\" model.\n\n\n`Multi-select` listbox implements the keyboard recommendations here: <https://www.w3.org/WAI/ARIA/apg/patterns/listbox/#keyboard_interaction>\n\n  - <kbd>Shift + Down Arrow</kbd>: Moves focus to and toggles the selected state of the next option.\n  - <kbd>Shift + Up Arrow</kbd>: Moves focus to and toggles the selected state of the previous option.\n  - <kbd>Shift + Space</kbd>: Selects contiguous items from the most recently selected item to the focused item.\n  - <kbd>Control + Shift + Home</kbd>: Selects the focused option and all options up to the first option. Optionally, moves focus to the first option.\n  - <kbd>Control + Shift + End</kbd>: Selects the focused option and all options down to the last option.\n  - <kbd>Control + a</kbd>: Selects all\n\n  The currently hovered / focus `<role-option>` has `[aria-current=\"true\"]`\n\n  The currently selected `<role-option>` has `[aria-selected=\"true\"]`",
          "name": "RoleListbox",
          "members": [
            {
              "kind": "field",
              "name": "baseName",
              "type": {
                "text": "string"
              },
              "static": true,
              "default": "\"role-listbox\""
            },
            {
              "kind": "method",
              "name": "formResetCallback"
            },
            {
              "kind": "method",
              "name": "setFocus",
              "parameters": [
                {
                  "name": "option",
                  "type": {
                    "text": "HTMLElement"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "removeFocus",
              "parameters": [
                {
                  "name": "option",
                  "type": {
                    "text": "HTMLElement"
                  }
                }
              ]
            },
            {
              "kind": "field",
              "name": "baseElement",
              "type": {
                "text": "HTMLElement | null | undefined"
              },
              "readonly": true
            },
            {
              "kind": "method",
              "name": "handleOptionClick",
              "parameters": [
                {
                  "name": "evt",
                  "type": {
                    "text": "PointerEvent"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "handleOptionHover",
              "parameters": [
                {
                  "name": "evt",
                  "type": {
                    "text": "Event"
                  }
                }
              ]
            },
            {
              "kind": "field",
              "name": "currentOptionIndex",
              "readonly": true
            },
            {
              "kind": "method",
              "name": "handleKeyUp",
              "parameters": [
                {
                  "name": "evt",
                  "type": {
                    "text": "KeyboardEvent"
                  }
                }
              ],
              "description": "Reset range when shiftKey goes up"
            },
            {
              "kind": "method",
              "name": "handleKeyDown",
              "parameters": [
                {
                  "name": "evt",
                  "type": {
                    "text": "KeyboardEvent"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "selectFromClosestSelectedToCurrent",
              "description": "Finds the closest selected option prior to the current option"
            },
            {
              "kind": "method",
              "name": "selectFromRangeStartToCurrent"
            },
            {
              "kind": "method",
              "name": "selectRange",
              "parameters": [
                {
                  "name": "{ from, to }"
                },
                {
                  "name": "options",
                  "type": {
                    "text": "Range"
                  }
                }
              ],
              "description": "Selects all options in a range and deselects all options not in the range"
            },
            {
              "kind": "method",
              "name": "selectFromStartToCurrent",
              "parameters": [
                {
                  "name": "startIndex",
                  "default": "0",
                  "optional": true,
                  "type": {
                    "text": "number"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "selectFromCurrentToEnd",
              "parameters": [
                {
                  "name": "endIndex",
                  "default": "this.options.length - 1",
                  "optional": true,
                  "type": {
                    "text": "number"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "focusElementFromSearchBuffer"
            },
            {
              "kind": "method",
              "name": "select",
              "parameters": [
                {
                  "name": "element",
                  "type": {
                    "text": "HTMLElement"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "deselect",
              "parameters": [
                {
                  "name": "element",
                  "type": {
                    "text": "HTMLElement"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "selectAll",
              "description": "Mark every element with [aria-selected=\"true\"]"
            },
            {
              "kind": "method",
              "name": "deselectAll",
              "description": "Mark every element with [aria-selected=\"false\"]"
            },
            {
              "kind": "method",
              "name": "toggleSelected",
              "parameters": [
                {
                  "name": "selectedElement",
                  "type": {
                    "text": "HTMLElement"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "focusCurrent"
            },
            {
              "kind": "method",
              "name": "focusAt",
              "parameters": [
                {
                  "name": "index",
                  "type": {
                    "text": "number"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "focusNext"
            },
            {
              "kind": "method",
              "name": "focusPrevious"
            },
            {
              "kind": "method",
              "name": "focusFirst"
            },
            {
              "kind": "method",
              "name": "focusLast"
            },
            {
              "kind": "method",
              "name": "scrollOptionIntoView",
              "parameters": [
                {
                  "name": "selectedOption",
                  "type": {
                    "text": "HTMLElement"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "void"
                }
              }
            },
            {
              "kind": "method",
              "name": "handleFocusIn",
              "parameters": [
                {
                  "name": "_evt",
                  "type": {
                    "text": "FocusEvent"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "isSelected",
              "parameters": [
                {
                  "name": "el",
                  "type": {
                    "text": "HTMLElement"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "boolean"
                }
              }
            },
            {
              "kind": "method",
              "name": "updateOptions"
            },
            {
              "kind": "method",
              "name": "assignRandomId",
              "parameters": [
                {
                  "name": "el",
                  "type": {
                    "text": "HTMLElement"
                  }
                }
              ],
              "description": "Users dont always provide ids on elements, and we need to make sure the id isn't already taken."
            },
            {
              "kind": "field",
              "name": "value",
              "type": {
                "text": "null | FormData | string"
              },
              "default": "null"
            },
            {
              "kind": "field",
              "name": "selectedOptions",
              "type": {
                "text": "HTMLElement[]"
              },
              "default": "[]"
            },
            {
              "kind": "field",
              "name": "rangeStartOption",
              "privacy": "public",
              "type": {
                "text": "null | HTMLElement"
              },
              "default": "null"
            },
            {
              "kind": "field",
              "name": "wrapSelection",
              "privacy": "public",
              "type": {
                "text": "boolean"
              },
              "default": "false",
              "attribute": "wrap-selection",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "role",
              "type": {
                "text": "string"
              },
              "default": "\"presentation\""
            },
            {
              "kind": "field",
              "name": "autocomplete",
              "privacy": "public",
              "type": {
                "text": "string"
              },
              "default": "\"off\"",
              "attribute": "autocomplete"
            },
            {
              "kind": "field",
              "name": "multiple",
              "privacy": "public",
              "type": {
                "text": "boolean"
              },
              "default": "false",
              "attribute": "multiple",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "tabIndex",
              "privacy": "public",
              "type": {
                "text": "number"
              },
              "default": "0",
              "attribute": "tabindex",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "label",
              "privacy": "public",
              "type": {
                "text": "string"
              },
              "default": "\"\"",
              "attribute": "label",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "searchBufferDelay",
              "privacy": "public",
              "type": {
                "text": "number"
              },
              "description": "Delay before the search buffer returns to an empty string",
              "default": "1000",
              "attribute": "search-buffer-delay",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "options",
              "privacy": "public",
              "type": {
                "text": "HTMLElement[]"
              },
              "default": "[]"
            },
            {
              "kind": "field",
              "name": "currentOption",
              "privacy": "public",
              "type": {
                "text": "null | HTMLElement"
              },
              "default": "null"
            },
            {
              "kind": "field",
              "name": "attributeFilter",
              "type": {
                "text": "array"
              },
              "default": "[ \"aria-current\", \"selected\", \"current\", \"aria-selected\", \"role\", ]"
            },
            {
              "kind": "field",
              "name": "optionObserver",
              "description": "Monitors its DOM for new nodes and assigns them to `this.options`",
              "type": {
                "text": "MutationObserver"
              },
              "default": "new MutationObserver((mutations) => { for (const { attributeName } of mutations) { if (attributeName == null) continue; if (this.attributeFilter.includes(attributeName)) { this.debounce(() => this.updateOptions(), { wait: 10, key: this.updateOptions, }); } // We really care about the mutations, we just need to know if things are updating. break; } })"
            },
            {
              "kind": "field",
              "name": "length",
              "privacy": "public",
              "attribute": "length"
            },
            {
              "kind": "field",
              "name": "_hasFocused",
              "privacy": "public"
            },
            {
              "kind": "field",
              "name": "_searchBuffer",
              "privacy": "public",
              "ignore": true,
              "type": {
                "text": "string"
              },
              "description": "Internal buffer for searching the listbox.",
              "default": "\"\""
            },
            {
              "kind": "field",
              "name": "_searchBufferDebounce",
              "privacy": "public",
              "ignore": true,
              "type": {
                "text": "null | ReturnType<typeof setTimeout>"
              },
              "description": "timeoutId to clear the search buffer",
              "default": "null"
            },
            {
              "kind": "field",
              "name": "dependencies",
              "static": true,
              "type": {
                "text": "Record<string, typeof HTMLElement>"
              },
              "readonly": true,
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "method",
              "name": "debounce",
              "parameters": [
                {
                  "name": "callback",
                  "type": {
                    "text": "(...args: any[]) => any"
                  }
                },
                {
                  "name": "options",
                  "type": {
                    "text": "{ key: any, wait: number }"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "ReturnType<typeof setTimeout>"
                }
              },
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "eventHandler",
              "type": {
                "text": "EventHandler<this>"
              },
              "default": "new EventHandler(this)",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "__debounceMap__",
              "type": {
                "text": "null | Map<any, ReturnType<typeof setTimeout>>"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            }
          ],
          "attributes": [
            {
              "name": "autocomplete",
              "type": {
                "text": "string"
              },
              "default": "\"off\"",
              "fieldName": "autocomplete"
            },
            {
              "name": "multiple",
              "type": {
                "text": "boolean"
              },
              "default": "false",
              "fieldName": "multiple"
            },
            {
              "name": "length",
              "fieldName": "length"
            },
            {
              "name": "label",
              "type": {
                "text": "string"
              },
              "default": "\"\"",
              "fieldName": "label"
            },
            {
              "name": "wrap-selection",
              "type": {
                "text": "boolean"
              },
              "default": "false",
              "fieldName": "wrapSelection"
            },
            {
              "name": "search-buffer-delay",
              "type": {
                "text": "number"
              },
              "description": "Delay before the search buffer returns to an empty string",
              "default": "1000",
              "fieldName": "searchBufferDelay"
            },
            {
              "name": "tabindex",
              "type": {
                "text": "number"
              },
              "default": "0",
              "fieldName": "tabIndex"
            }
          ],
          "mixins": [
            {
              "name": "LitFormAssociatedMixin",
              "package": "form-associated-helpers/exports/mixins/lit-form-associated-mixin.js"
            }
          ],
          "superclass": {
            "name": "BaseElement",
            "module": "/exports/base-element.js"
          },
          "tagName": "role-listbox",
          "customElement": true
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "RoleListbox",
            "module": "exports/listbox/listbox.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/option/option-register.js",
      "declarations": [],
      "exports": [
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "RoleOption",
            "module": "exports/option/option-register.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/option/option.js",
      "declarations": [
        {
          "kind": "class",
          "description": "",
          "name": "RoleOption",
          "members": [
            {
              "kind": "field",
              "name": "baseName",
              "type": {
                "text": "string"
              },
              "static": true,
              "default": "\"role-option\""
            },
            {
              "kind": "field",
              "name": "validators",
              "static": true,
              "readonly": true
            },
            {
              "kind": "method",
              "name": "formResetCallback"
            },
            {
              "kind": "method",
              "name": "handleSlotChange"
            },
            {
              "kind": "method",
              "name": "handleFocus",
              "description": "Sends a bubbling focus event to be usable by the combobox."
            },
            {
              "kind": "method",
              "name": "handleBlur",
              "description": "Sends a bubbling focus event to be usable by the combobox."
            },
            {
              "kind": "method",
              "name": "simulateLinkClick"
            },
            {
              "kind": "method",
              "name": "renderBase",
              "parameters": [
                {
                  "name": "content",
                  "type": {
                    "text": "ReturnType<html>"
                  }
                }
              ]
            },
            {
              "kind": "field",
              "name": "linkAttributes",
              "type": {
                "text": "typeof linkAttributes"
              },
              "default": "([ \"download\", \"href\", \"hreflang\", \"ping\", \"referrerpolicy\", \"rel\", \"target\", \"type\", ])"
            },
            {
              "kind": "field",
              "name": "role",
              "type": {
                "text": "string"
              },
              "default": "\"presentation\""
            },
            {
              "kind": "field",
              "name": "selected",
              "privacy": "public",
              "type": {
                "text": "boolean"
              },
              "description": "aria-selected is preferred for single-select listboxes / comboboxes",
              "default": "false",
              "attribute": "selected"
            },
            {
              "kind": "field",
              "name": "defaultSelected",
              "privacy": "public",
              "type": {
                "text": "boolean"
              },
              "description": "The selection state when the form is reset",
              "attribute": "selected",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "current",
              "privacy": "public",
              "type": {
                "text": "boolean"
              },
              "description": "aria-current to show the currently focused option",
              "default": "false",
              "attribute": "current"
            },
            {
              "kind": "field",
              "name": "hasFocus",
              "type": {
                "text": "boolean"
              },
              "default": "false"
            },
            {
              "kind": "field",
              "name": "value",
              "type": {
                "text": "null | string"
              },
              "default": "null"
            },
            {
              "kind": "field",
              "name": "label",
              "privacy": "public",
              "type": {
                "text": "string"
              },
              "attribute": "label"
            },
            {
              "kind": "field",
              "name": "tabIndex",
              "privacy": "public",
              "type": {
                "text": "number"
              },
              "default": "-1",
              "attribute": "tabindex",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "ariaCurrent",
              "privacy": "public",
              "attribute": "aria-current",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "ariaSelected",
              "privacy": "public",
              "attribute": "aria-selected",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "disabled",
              "privacy": "public",
              "type": {
                "text": "boolean"
              },
              "attribute": "disabled"
            },
            {
              "kind": "field",
              "name": "download",
              "type": {
                "text": "string | null"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "LinkMixin",
                "module": "exports/option/option.js"
              }
            },
            {
              "kind": "field",
              "name": "href",
              "type": {
                "text": "string | null"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "LinkMixin",
                "module": "exports/option/option.js"
              }
            },
            {
              "kind": "field",
              "name": "hreflang",
              "type": {
                "text": "string | null"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "LinkMixin",
                "module": "exports/option/option.js"
              }
            },
            {
              "kind": "field",
              "name": "ping",
              "type": {
                "text": "string | null"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "LinkMixin",
                "module": "exports/option/option.js"
              }
            },
            {
              "kind": "field",
              "name": "referrerpolicy",
              "type": {
                "text": "string | null"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "LinkMixin",
                "module": "exports/option/option.js"
              }
            },
            {
              "kind": "field",
              "name": "rel",
              "type": {
                "text": "string | null"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "LinkMixin",
                "module": "exports/option/option.js"
              }
            },
            {
              "kind": "field",
              "name": "target",
              "type": {
                "text": "string | null"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "LinkMixin",
                "module": "exports/option/option.js"
              }
            },
            {
              "kind": "field",
              "name": "type",
              "type": {
                "text": "string | null"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "LinkMixin",
                "module": "exports/option/option.js"
              }
            },
            {
              "kind": "field",
              "name": "dependencies",
              "static": true,
              "type": {
                "text": "Record<string, typeof HTMLElement>"
              },
              "readonly": true,
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "method",
              "name": "debounce",
              "parameters": [
                {
                  "name": "callback",
                  "type": {
                    "text": "(...args: any[]) => any"
                  }
                },
                {
                  "name": "options",
                  "type": {
                    "text": "{ key: any, wait: number }"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "ReturnType<typeof setTimeout>"
                }
              },
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "eventHandler",
              "type": {
                "text": "EventHandler<this>"
              },
              "default": "new EventHandler(this)",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "__debounceMap__",
              "type": {
                "text": "null | Map<any, ReturnType<typeof setTimeout>>"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            }
          ],
          "events": [
            {
              "name": "role-focus",
              "type": {
                "text": "Event"
              }
            },
            {
              "name": "role-blur",
              "type": {
                "text": "Event"
              }
            }
          ],
          "attributes": [
            {
              "name": "selected",
              "type": {
                "text": "boolean"
              },
              "description": "aria-selected is preferred for single-select listboxes / comboboxes",
              "fieldName": "selected",
              "default": "false"
            },
            {
              "name": "current",
              "type": {
                "text": "boolean"
              },
              "description": "aria-current to show the currently focused option",
              "default": "false",
              "fieldName": "current"
            },
            {
              "name": "aria-current",
              "fieldName": "ariaCurrent"
            },
            {
              "name": "aria-selected",
              "fieldName": "ariaSelected"
            },
            {
              "name": "disabled",
              "type": {
                "text": "boolean"
              },
              "fieldName": "disabled"
            },
            {
              "name": "label",
              "type": {
                "text": "string"
              },
              "fieldName": "label"
            },
            {
              "name": "tabindex",
              "type": {
                "text": "number"
              },
              "default": "-1",
              "fieldName": "tabIndex"
            }
          ],
          "mixins": [
            {
              "name": "LitFormAssociatedMixin",
              "package": "form-associated-helpers/exports/mixins/lit-form-associated-mixin.js"
            },
            {
              "name": "LinkMixin",
              "module": "exports/option/option.js"
            }
          ],
          "superclass": {
            "name": "BaseElement",
            "module": "/exports/base-element.js"
          },
          "tagName": "role-option",
          "customElement": true
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "RoleOption",
            "module": "exports/option/option.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/option-group/option-group-register.js",
      "declarations": [],
      "exports": [
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "RoleOptionGroup",
            "module": "exports/option-group/option-group-register.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/option-group/option-group.js",
      "declarations": [
        {
          "kind": "class",
          "description": "",
          "name": "OptionGroup",
          "members": [
            {
              "kind": "field",
              "name": "baseName",
              "type": {
                "text": "string"
              },
              "static": true,
              "default": "\"role-option-group\""
            },
            {
              "kind": "field",
              "name": "role",
              "privacy": "public",
              "type": {
                "text": "string"
              },
              "default": "\"group\"",
              "attribute": "role",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "dependencies",
              "static": true,
              "type": {
                "text": "Record<string, typeof HTMLElement>"
              },
              "readonly": true,
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "method",
              "name": "debounce",
              "parameters": [
                {
                  "name": "callback",
                  "type": {
                    "text": "(...args: any[]) => any"
                  }
                },
                {
                  "name": "options",
                  "type": {
                    "text": "{ key: any, wait: number }"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "ReturnType<typeof setTimeout>"
                }
              },
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "eventHandler",
              "type": {
                "text": "EventHandler<this>"
              },
              "default": "new EventHandler(this)",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "__debounceMap__",
              "type": {
                "text": "null | Map<any, ReturnType<typeof setTimeout>>"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            }
          ],
          "attributes": [
            {
              "name": "role",
              "type": {
                "text": "string"
              },
              "default": "\"group\"",
              "fieldName": "role"
            }
          ],
          "superclass": {
            "name": "BaseElement",
            "module": "/exports/base-element.js"
          },
          "tagName": "role-option-group",
          "customElement": true
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "OptionGroup",
            "module": "exports/option-group/option-group.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/styles/host-styles.js",
      "declarations": [
        {
          "kind": "variable",
          "name": "visuallyHiddenStr",
          "default": "css` clip: rect(0 0 0 0); clip-path: inset(50%); height: 1px; overflow: hidden; position: absolute; white-space: nowrap; width: 1px; `"
        },
        {
          "kind": "variable",
          "name": "hostStyles",
          "default": "css` :host { --role-background-hover-color: #005a9c; --role-border-focus-color: #005a9c; display: block; box-sizing: border-box; } *, *:after, *:before { box-sizing: border-box; } [hidden] { display: none !important; } [invisible] { visibility: hidden !important; } .visually-hidden:not(:focus-within):not(:active) { clip: rect(0 0 0 0); clip-path: inset(50%); height: 1px; overflow: hidden; position: absolute; white-space: nowrap; width: 1px; } `"
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "visuallyHiddenStr",
          "declaration": {
            "name": "visuallyHiddenStr",
            "module": "exports/styles/host-styles.js"
          }
        },
        {
          "kind": "js",
          "name": "hostStyles",
          "declaration": {
            "name": "hostStyles",
            "module": "exports/styles/host-styles.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/toolbar/toolbar-register.js",
      "declarations": [],
      "exports": [
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "RoleToolbar",
            "module": "exports/toolbar/toolbar-register.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/toolbar/toolbar.js",
      "declarations": [
        {
          "kind": "class",
          "description": "A toolbar following the W3C Toolbar pattern.\n<https://www.w3.org/WAI/ARIA/apg/patterns/toolbar/>",
          "name": "RoleToolbar",
          "members": [
            {
              "kind": "field",
              "name": "baseName",
              "static": true,
              "return": {
                "type": {
                  "text": "string"
                }
              },
              "readonly": true
            },
            {
              "kind": "field",
              "name": "keydownHandlers",
              "return": {
                "type": {
                  "text": "Record<string, (event: Event) => void>"
                }
              },
              "readonly": true
            },
            {
              "kind": "method",
              "name": "handleClick",
              "parameters": [
                {
                  "name": "event",
                  "type": {
                    "text": "Event"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "handleKeyDown",
              "parameters": [
                {
                  "name": "event",
                  "type": {
                    "text": "KeyboardEvent"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "focusNext",
              "parameters": [
                {
                  "name": "_event",
                  "type": {
                    "text": "Event"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "focusPrevious",
              "parameters": [
                {
                  "name": "_event",
                  "type": {
                    "text": "Event"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "focusFirst"
            },
            {
              "kind": "method",
              "name": "focusLast"
            },
            {
              "kind": "method",
              "name": "setTabIndex",
              "parameters": [
                {
                  "name": "{ focus = true }",
                  "default": "{}"
                }
              ]
            },
            {
              "kind": "field",
              "name": "currentFocusElement",
              "readonly": true
            },
            {
              "kind": "method",
              "name": "updateToolbarItems",
              "parameters": [
                {
                  "name": "evt",
                  "description": "triggered by a slot change event.",
                  "optional": true,
                  "type": {
                    "text": "undefined | null | Event"
                  }
                }
              ]
            },
            {
              "kind": "field",
              "name": "_currentFocusIndex",
              "privacy": "public",
              "type": {
                "text": "number"
              },
              "default": "0",
              "attribute": "_currentFocusIndex"
            },
            {
              "kind": "field",
              "name": "orientation",
              "privacy": "public",
              "type": {
                "text": "\"vertical\" | \"horizontal\""
              },
              "default": "\"horizontal\"",
              "attribute": "orientation",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "_toolbarItems",
              "privacy": "public",
              "type": {
                "text": "Array<Element>"
              },
              "default": "[]",
              "attribute": "_toolbarItems"
            },
            {
              "kind": "field",
              "name": "ariaOrientation",
              "privacy": "public",
              "attribute": "ariaOrientation",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "dependencies",
              "static": true,
              "type": {
                "text": "Record<string, typeof HTMLElement>"
              },
              "readonly": true,
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "method",
              "name": "debounce",
              "parameters": [
                {
                  "name": "callback",
                  "type": {
                    "text": "(...args: any[]) => any"
                  }
                },
                {
                  "name": "options",
                  "type": {
                    "text": "{ key: any, wait: number }"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "ReturnType<typeof setTimeout>"
                }
              },
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "eventHandler",
              "type": {
                "text": "EventHandler<this>"
              },
              "default": "new EventHandler(this)",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "__debounceMap__",
              "type": {
                "text": "null | Map<any, ReturnType<typeof setTimeout>>"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            }
          ],
          "attributes": [
            {
              "name": "orientation",
              "type": {
                "text": "\"vertical\" | \"horizontal\""
              },
              "default": "\"horizontal\"",
              "fieldName": "orientation"
            },
            {
              "name": "ariaOrientation",
              "fieldName": "ariaOrientation"
            },
            {
              "name": "_currentFocusIndex",
              "type": {
                "text": "number"
              },
              "default": "0",
              "fieldName": "_currentFocusIndex"
            },
            {
              "name": "_toolbarItems",
              "type": {
                "text": "Array<Element>"
              },
              "default": "[]",
              "fieldName": "_toolbarItems"
            }
          ],
          "superclass": {
            "name": "BaseElement",
            "module": "/exports/base-element.js"
          },
          "tagName": "role-toolbar",
          "customElement": true
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "RoleToolbar",
            "module": "exports/toolbar/toolbar.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/tooltip/tooltip-register.js",
      "declarations": [],
      "exports": [
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "RoleTooltip",
            "module": "exports/tooltip/tooltip-register.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "exports/tooltip/tooltip.js",
      "declarations": [
        {
          "kind": "class",
          "description": "Due to accessibility reasons with aria-describedby, the tooltip must be the same\n  document / shadowRoot as the item being described by the tooltip.",
          "name": "RoleTooltip",
          "cssProperties": [
            {
              "name": "--background-color",
              "default": "#222"
            },
            {
              "name": "--arrow-size",
              "default": "8px"
            }
          ],
          "cssParts": [
            {
              "name": "popover"
            },
            {
              "name": "popover--active"
            },
            {
              "name": "popover--fixed"
            },
            {
              "name": "popover--has-arrow"
            },
            {
              "name": "arrow"
            },
            {
              "name": "hover-bridge"
            },
            {
              "name": "hover-bridge--visible"
            }
          ],
          "slots": [
            {
              "description": "default slot",
              "name": ""
            }
          ],
          "members": [
            {
              "kind": "field",
              "name": "dependencies",
              "static": true,
              "type": {
                "text": "Record<string, typeof HTMLElement>"
              },
              "readonly": true,
              "default": "{ 'role-anchored-region': RoleAnchoredRegion }",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "baseName",
              "static": true,
              "return": {
                "type": {
                  "text": "string"
                }
              },
              "readonly": true
            },
            {
              "kind": "method",
              "name": "handlePopoverTriggerEvent",
              "parameters": [
                {
                  "name": "e",
                  "type": {
                    "text": "RoleTooltipToggle"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "handleReposition"
            },
            {
              "kind": "field",
              "name": "popoverIsOpen",
              "description": "A helper that actually inspects the popover's state.",
              "readonly": true
            },
            {
              "kind": "field",
              "name": "anchoredRegion",
              "readonly": true
            },
            {
              "kind": "method",
              "name": "handleKeyDown",
              "parameters": [
                {
                  "name": "e",
                  "type": {
                    "text": "KeyboardEvent"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "handleFocusChange",
              "description": "This is a hack. Unfortunately, there's no reliable way to get the active elements from just \"focusin\" / \"focusout\""
            },
            {
              "kind": "method",
              "name": "handleShow",
              "parameters": [
                {
                  "name": "event",
                  "type": {
                    "text": "Event"
                  }
                }
              ],
              "description": "Used to show from event listeners."
            },
            {
              "kind": "method",
              "name": "show",
              "parameters": [
                {
                  "name": "triggerElement",
                  "type": {
                    "text": "Element"
                  }
                },
                {
                  "name": "triggerSource",
                  "default": "null",
                  "type": {
                    "text": "RoleTooltip[\"__triggerSource\"]"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "void"
                }
              }
            },
            {
              "kind": "method",
              "name": "findTriggerForTooltip",
              "parameters": [
                {
                  "name": "e",
                  "type": {
                    "text": "Event"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "handleHide",
              "parameters": [
                {
                  "name": "event",
                  "type": {
                    "text": "Event"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "void"
                }
              }
            },
            {
              "kind": "method",
              "name": "hide",
              "parameters": [
                {
                  "name": "triggerSource",
                  "optional": true,
                  "type": {
                    "text": "null | RoleTooltip[\"__triggerSource\"]"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "void"
                }
              }
            },
            {
              "kind": "field",
              "name": "popover",
              "privacy": "public",
              "type": {
                "text": "\"auto\" | \"manual\""
              },
              "description": "A popover attribute can have values \"auto\" (default) or \"manual\". Popovers that have the auto state can be \"light dismissed\" by selecting outside the popover area, and generally only allow one popover to be displayed on-screen at a time. By contrast, manual popovers must always be explicitly hidden, but allow for use cases such as nested popovers in menus",
              "default": "\"manual\"",
              "attribute": "popover",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "role",
              "privacy": "public",
              "type": {
                "text": "string"
              },
              "description": "The \"role\" attribute. Default is \"tooltip\" and generally shouldn't be overriden.",
              "default": "\"tooltip\"",
              "attribute": "role",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "active",
              "privacy": "public",
              "type": {
                "text": "boolean"
              },
              "description": "Whether or not to show the tooltip",
              "default": "false",
              "attribute": "active",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "anchor",
              "privacy": "public",
              "type": {
                "text": "Element | null"
              },
              "default": "null"
            },
            {
              "kind": "field",
              "name": "arrow",
              "description": "Attaches an arrow to the popover. The arrow's size and color can be customized using the `--arrow-size` and\n`--background-color` custom properties. For additional customizations, you can also target the arrow using\n`::part(arrow)` in your stylesheet.",
              "type": {
                "text": "boolean"
              },
              "attribute": "arrow",
              "default": "true",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "distance",
              "description": "The distance in pixels from which to offset along the \"main axis\". Usually its equivalent to offsetY",
              "type": {
                "text": "number"
              },
              "attribute": "distance",
              "default": "10",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "__triggerSource",
              "privacy": "private",
              "type": {
                "text": "null | \"focus\" | \"hover\" | \"click\""
              },
              "default": "null",
              "attribute": "trigger-source",
              "reflects": true
            },
            {
              "kind": "field",
              "name": "__eventAbortController",
              "privacy": "private",
              "default": "new AbortController()"
            },
            {
              "kind": "field",
              "name": "__activeElements",
              "type": {
                "text": "Element[]"
              },
              "default": "[]"
            },
            {
              "kind": "field",
              "name": "placement",
              "description": "The preferred placement of the popover. Note that the actual placement will vary as configured to keep the\npanel inside of the viewport.",
              "type": {
                "text": "'top'\n          | 'top-start'\n          | 'top-end'\n          | 'bottom'\n          | 'bottom-start'\n          | 'bottom-end'\n          | 'right'\n          | 'right-start'\n          | 'right-end'\n          | 'left'\n          | 'left-start'\n          | 'left-end'"
              },
              "attribute": "placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "currentPlacement",
              "description": "The `currentPlacement` property / `current-placement` attribute are where Floating UI actually positions the popup.",
              "reflects": true,
              "type": {
                "text": "this[\"placement\"] | null"
              },
              "attribute": "current-placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "strategy",
              "description": "Determines how the popover is positioned. Because you native \"popover\" API uses a fixed strategy, we use it as the default.",
              "type": {
                "text": "Strategy"
              },
              "attribute": "strategy",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "skidding",
              "description": "The distance in pixels from which to offset along the \"cross axis\". Usually its equivalent to offsetX.",
              "type": {
                "text": "number"
              },
              "attribute": "skidding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "arrowPlacement",
              "description": "The placement of the arrow. The default is `anchor`, which will align the arrow as close to the center of the\nanchor as possible, considering available space and `arrow-padding`. A value of `start`, `end`, or `center` will\nalign the arrow to the start, end, or center of the popover instead.",
              "type": {
                "text": "'start' | 'end' | 'center' | 'anchor'"
              },
              "attribute": "arrow-placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "arrowPadding",
              "description": "The amount of padding between the arrow and the edges of the popover. If the popover has a border-radius, for example,\nthis will prevent it from overflowing the corners.",
              "type": {
                "text": "number"
              },
              "attribute": "arrow-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flip",
              "description": "When set, placement of the popover will flip to the opposite site to keep it in view. You can use\n`flipFallbackPlacements` to further configure how the fallback placement is determined.",
              "type": {
                "text": "boolean"
              },
              "attribute": "flip",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flipFallbackPlacements",
              "description": "If the preferred placement doesn't fit, popover will be tested in these fallback placements until one fits. Must be a\nstring of any number of placements separated by a space, e.g. \"top bottom left\". If no placement fits, the flip\nfallback strategy will be used instead.",
              "type": {
                "text": "string"
              },
              "attribute": "flip-fallback-placements",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flipFallbackStrategy",
              "description": "When neither the preferred placement nor the fallback placements fit, this value will be used to determine whether\nthe popover should be positioned using the best available fit based on available space or as it was initially\npreferred.",
              "type": {
                "text": "'best-fit' | 'initial'"
              },
              "attribute": "flip-fallback-strategy",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flipBoundary",
              "description": "The flip boundary describes clipping element(s) that overflow will be checked relative to when flipping. By\ndefault, the boundary includes overflow ancestors that will cause the element to be clipped. If needed, you can\nchange the boundary by passing a reference to one or more elements to this property.",
              "type": {
                "text": "undefined | Element | Element[]"
              },
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "flipPadding",
              "description": "The amount of padding, in pixels, to exceed before the flip behavior will occur.",
              "type": {
                "text": "number"
              },
              "attribute": "flip-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "shift",
              "description": "Moves the popover along the axis to keep it in view when clipped.",
              "type": {
                "text": "boolean"
              },
              "attribute": "shift",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "shiftBoundary",
              "description": "The shift boundary describes clipping element(s) that overflow will be checked relative to when shifting. By\ndefault, the boundary includes overflow ancestors that will cause the element to be clipped. If needed, you can\nchange the boundary by passing a reference to one or more elements to this property.",
              "type": {
                "text": "undefined | Element | Element[]"
              },
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "shiftPadding",
              "description": "The amount of padding, in pixels, to exceed before the shift behavior will occur.",
              "type": {
                "text": "number"
              },
              "attribute": "shift-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "autoSize",
              "description": "When set, this will cause the popover to automatically resize itself to prevent it from overflowing.",
              "type": {
                "text": "null | 'horizontal' | 'vertical' | 'both'"
              },
              "attribute": "auto-size",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "sync",
              "description": "Syncs the popover's width or height to that of the anchor element.",
              "type": {
                "text": "null | 'width' | 'height' | 'both'"
              },
              "attribute": "sync",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "autoSizeBoundary",
              "description": "The auto-size boundary describes clipping element(s) that overflow will be checked relative to when resizing. By\ndefault, the boundary includes overflow ancestors that will cause the element to be clipped. If needed, you can\nchange the boundary by passing a reference to one or more elements to this property.",
              "type": {
                "text": "undefined | Element | Element[]"
              },
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "autoSizePadding",
              "description": "The amount of padding, in pixels, to exceed before the auto-size behavior will occur.",
              "type": {
                "text": "number"
              },
              "attribute": "auto-size-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "field",
              "name": "hoverBridge",
              "description": "When a gap exists between the anchor and the popover element, this option will add a \"hover bridge\" that fills the\ngap using an invisible element. This makes listening for events such as `mouseenter` and `mouseleave` more sane\nbecause the pointer never technically leaves the element. The hover bridge will only be drawn when the popover is\nactive.",
              "type": {
                "text": "boolean"
              },
              "attribute": "hover-bridge",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "kind": "method",
              "name": "debounce",
              "parameters": [
                {
                  "name": "callback",
                  "type": {
                    "text": "(...args: any[]) => any"
                  }
                },
                {
                  "name": "options",
                  "type": {
                    "text": "{ key: any, wait: number }"
                  }
                }
              ],
              "return": {
                "type": {
                  "text": "ReturnType<typeof setTimeout>"
                }
              },
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "eventHandler",
              "type": {
                "text": "EventHandler<this>"
              },
              "default": "new EventHandler(this)",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            },
            {
              "kind": "field",
              "name": "__debounceMap__",
              "type": {
                "text": "null | Map<any, ReturnType<typeof setTimeout>>"
              },
              "default": "null",
              "inheritedFrom": {
                "name": "BaseElement",
                "module": "exports/base-element.js"
              }
            }
          ],
          "attributes": [
            {
              "name": "role",
              "type": {
                "text": "string"
              },
              "description": "The \"role\" attribute. Default is \"tooltip\" and generally shouldn't be overriden.",
              "default": "\"tooltip\"",
              "fieldName": "role"
            },
            {
              "name": "active",
              "type": {
                "text": "boolean"
              },
              "description": "Whether or not to show the tooltip",
              "default": "false",
              "fieldName": "active"
            },
            {
              "name": "popover",
              "type": {
                "text": "\"auto\" | \"manual\""
              },
              "description": "A popover attribute can have values \"auto\" (default) or \"manual\". Popovers that have the auto state can be \"light dismissed\" by selecting outside the popover area, and generally only allow one popover to be displayed on-screen at a time. By contrast, manual popovers must always be explicitly hidden, but allow for use cases such as nested popovers in menus",
              "default": "\"manual\"",
              "fieldName": "popover"
            },
            {
              "name": "trigger-source",
              "type": {
                "text": "null | \"focus\" | \"hover\" | \"click\""
              },
              "default": "null",
              "fieldName": "__triggerSource"
            },
            {
              "name": "placement",
              "description": "The preferred placement of the popover. Note that the actual placement will vary as configured to keep the\npanel inside of the viewport.",
              "type": {
                "text": "'top'\n          | 'top-start'\n          | 'top-end'\n          | 'bottom'\n          | 'bottom-start'\n          | 'bottom-end'\n          | 'right'\n          | 'right-start'\n          | 'right-end'\n          | 'left'\n          | 'left-start'\n          | 'left-end'"
              },
              "fieldName": "placement",
              "attribute": "placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "current-placement",
              "description": "The `currentPlacement` property / `current-placement` attribute are where Floating UI actually positions the popup.",
              "type": {
                "text": "this[\"placement\"] | null"
              },
              "fieldName": "currentPlacement",
              "attribute": "current-placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "strategy",
              "description": "Determines how the popover is positioned. Because you native \"popover\" API uses a fixed strategy, we use it as the default.",
              "type": {
                "text": "Strategy"
              },
              "fieldName": "strategy",
              "attribute": "strategy",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "distance",
              "description": "The distance in pixels from which to offset along the \"main axis\". Usually its equivalent to offsetY",
              "type": {
                "text": "number"
              },
              "fieldName": "distance",
              "attribute": "distance",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "skidding",
              "description": "The distance in pixels from which to offset along the \"cross axis\". Usually its equivalent to offsetX.",
              "type": {
                "text": "number"
              },
              "fieldName": "skidding",
              "attribute": "skidding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "arrow",
              "description": "Attaches an arrow to the popover. The arrow's size and color can be customized using the `--arrow-size` and\n`--background-color` custom properties. For additional customizations, you can also target the arrow using\n`::part(arrow)` in your stylesheet.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "arrow",
              "attribute": "arrow",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "arrow-placement",
              "description": "The placement of the arrow. The default is `anchor`, which will align the arrow as close to the center of the\nanchor as possible, considering available space and `arrow-padding`. A value of `start`, `end`, or `center` will\nalign the arrow to the start, end, or center of the popover instead.",
              "type": {
                "text": "'start' | 'end' | 'center' | 'anchor'"
              },
              "fieldName": "arrowPlacement",
              "attribute": "arrow-placement",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "arrow-padding",
              "description": "The amount of padding between the arrow and the edges of the popover. If the popover has a border-radius, for example,\nthis will prevent it from overflowing the corners.",
              "type": {
                "text": "number"
              },
              "fieldName": "arrowPadding",
              "attribute": "arrow-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "flip",
              "description": "When set, placement of the popover will flip to the opposite site to keep it in view. You can use\n`flipFallbackPlacements` to further configure how the fallback placement is determined.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "flip",
              "attribute": "flip",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "flip-fallback-placements",
              "description": "If the preferred placement doesn't fit, popover will be tested in these fallback placements until one fits. Must be a\nstring of any number of placements separated by a space, e.g. \"top bottom left\". If no placement fits, the flip\nfallback strategy will be used instead.",
              "type": {
                "text": "string"
              },
              "fieldName": "flipFallbackPlacements",
              "attribute": "flip-fallback-placements",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "flip-fallback-strategy",
              "description": "When neither the preferred placement nor the fallback placements fit, this value will be used to determine whether\nthe popover should be positioned using the best available fit based on available space or as it was initially\npreferred.",
              "type": {
                "text": "'best-fit' | 'initial'"
              },
              "fieldName": "flipFallbackStrategy",
              "attribute": "flip-fallback-strategy",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "flip-padding",
              "description": "The amount of padding, in pixels, to exceed before the flip behavior will occur.",
              "type": {
                "text": "number"
              },
              "fieldName": "flipPadding",
              "attribute": "flip-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "shift",
              "description": "Moves the popover along the axis to keep it in view when clipped.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "shift",
              "attribute": "shift",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "shift-padding",
              "description": "The amount of padding, in pixels, to exceed before the shift behavior will occur.",
              "type": {
                "text": "number"
              },
              "fieldName": "shiftPadding",
              "attribute": "shift-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "auto-size",
              "description": "When set, this will cause the popover to automatically resize itself to prevent it from overflowing.",
              "type": {
                "text": "null | 'horizontal' | 'vertical' | 'both'"
              },
              "fieldName": "autoSize",
              "attribute": "auto-size",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "sync",
              "description": "Syncs the popover's width or height to that of the anchor element.",
              "type": {
                "text": "null | 'width' | 'height' | 'both'"
              },
              "fieldName": "sync",
              "attribute": "sync",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "auto-size-padding",
              "description": "The amount of padding, in pixels, to exceed before the auto-size behavior will occur.",
              "type": {
                "text": "number"
              },
              "fieldName": "autoSizePadding",
              "attribute": "auto-size-padding",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            },
            {
              "name": "hover-bridge",
              "description": "When a gap exists between the anchor and the popover element, this option will add a \"hover bridge\" that fills the\ngap using an invisible element. This makes listening for events such as `mouseenter` and `mouseleave` more sane\nbecause the pointer never technically leaves the element. The hover bridge will only be drawn when the popover is\nactive.",
              "type": {
                "text": "boolean"
              },
              "fieldName": "hoverBridge",
              "attribute": "hover-bridge",
              "inheritedFrom": {
                "name": "AnchoredRegionMixin",
                "module": "exports/anchored-region/anchored-region.js"
              }
            }
          ],
          "mixins": [
            {
              "name": "AnchoredRegionMixin",
              "module": "/exports/anchored-region/anchored-region.js"
            }
          ],
          "superclass": {
            "name": "BaseElement",
            "module": "/exports/base-element.js"
          },
          "tagName": "role-tooltip",
          "customElement": true
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "RoleTooltip",
            "module": "exports/tooltip/tooltip.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "internal/clamp.js",
      "declarations": [
        {
          "kind": "function",
          "name": "clamp",
          "parameters": [
            {
              "name": "min",
              "type": {
                "text": "number"
              }
            },
            {
              "name": "current",
              "type": {
                "text": "number"
              }
            },
            {
              "name": "max",
              "type": {
                "text": "number"
              }
            }
          ],
          "description": "If current > max, return max\nIf current < min, return min",
          "return": {
            "type": {
              "text": "number"
            }
          }
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "clamp",
          "declaration": {
            "name": "clamp",
            "module": "internal/clamp.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "internal/debounce.js",
      "declarations": [
        {
          "kind": "function",
          "name": "debounce",
          "parameters": [
            {
              "name": "callback",
              "type": {
                "text": "T"
              }
            },
            {
              "name": "wait",
              "type": {
                "text": "number"
              }
            }
          ]
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "debounce",
          "declaration": {
            "name": "debounce",
            "module": "internal/debounce.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "internal/is-mac-os.js",
      "declarations": [
        {
          "kind": "function",
          "name": "isMacOs",
          "description": "Detects if on a macOS device so we can properly bind things like metaKey\nhttps://developer.mozilla.org/en-US/docs/Web/API/Navigator/platform\n> But there is one case where, among the options you could use, navigator.platform may be the least-bad option: When you need to show users advice about whether the modifier key for keyboard shortcuts is the ⌘ command key (found on Apple systems) rather than the ⌃ control key (on non-Apple systems):"
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "isMacOs",
          "declaration": {
            "name": "isMacOs",
            "module": "internal/is-mac-os.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "internal/string-map.js",
      "declarations": [
        {
          "kind": "function",
          "name": "stringMap",
          "parameters": [
            {
              "name": "obj",
              "type": {
                "text": "Record<string, unknown>"
              }
            }
          ],
          "return": {
            "type": {
              "text": "string"
            }
          }
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "stringMap",
          "declaration": {
            "name": "stringMap",
            "module": "internal/string-map.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "internal/uuid.js",
      "declarations": [
        {
          "kind": "function",
          "name": "uuidv4",
          "description": "uuid generator for attaching unique ids to attachments that need uploading.",
          "return": {
            "type": {
              "text": "string"
            }
          }
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "uuidv4",
          "declaration": {
            "name": "uuidv4",
            "module": "internal/uuid.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "internal/wrap.js",
      "declarations": [
        {
          "kind": "function",
          "name": "wrap",
          "parameters": [
            {
              "name": "min",
              "type": {
                "text": "number"
              }
            },
            {
              "name": "current",
              "type": {
                "text": "number"
              }
            },
            {
              "name": "max",
              "type": {
                "text": "number"
              }
            }
          ],
          "description": "If current > max, return min\nIf current < min, return max",
          "return": {
            "type": {
              "text": "number"
            }
          }
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "wrap",
          "declaration": {
            "name": "wrap",
            "module": "internal/wrap.js"
          }
        }
      ]
    }
  ]
}
